type nat = mu nat .
  | O
  | S of nat

type natnatoption =
  | None
  | Some of nat * nat

type cmp =
  | LT
  | EQ
  | GT

let compare =
  fix (compare : nat -> nat -> cmp) =
    fun (x1 : nat) ->
      fun (x2 : nat) ->
        match x1 binding x1 with
        | O -> (match x2 binding x2 with
                | O -> EQ
                | S -> LT)
        | S -> (match x2 binding x2 with
                | O -> GT
                | S -> compare x1 x2)
;;

struct
  type t = natnatoption

  let empty = None ;;

  let is_empty =
    fun (r : t) ->
      (match r binding r with
       | None -> (True)
       | Some -> (False))
  ;;

  let contains =
    fun (r : t) -> fun (n : nat) ->
      match r binding r with
      | None -> False
      | Some ->
        (match compare r.0 n binding c with
         | LT -> (match compare r.1 n binding c with
                  | LT -> False
                  | EQ -> True
                  | GT -> True)
         | EQ -> True
         | GT -> False)
  ;;

  let expand =
    fun (r : t) -> fun (n : nat) ->
      match r binding rp with
      | None -> Some (n,n)
      | Some ->
        (match compare rp.0 n binding c with
         | LT -> (match compare rp.1 n binding c with
                  | LT -> Some (rp.0,n)
                  | EQ -> r
                  | GT -> r)
         | EQ -> r
         | GT -> Some (n,rp.1))
  ;;
end
:
sig
  type t

  val empty : t

  val is_empty : t -> bool

  val contains : t -> nat -> bool

  val expand : t -> nat -> t

  (*val union : t -> t -> t
  val inter : t -> t -> t*)
end

maintains

forall (r : t) .
  forall (i : nat) .
    forall (j : nat) .
      (and
        (contains (expand r i) i)
        (not (contains empty i)))

accumulating unit