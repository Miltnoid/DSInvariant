type nat = mu nat .
  | O
  | S of nat

let add =
  fix (add : nat -> nat -> nat) =
    fun (x1 : nat) ->
      fun (x2 : nat) ->
        match x1 binding x1 with
        | O -> x2
        | S -> add x1 (S x2)
;;

type cmp =
  | LT
  | EQ
  | GT

let compare =
  fix (compare : nat -> nat -> cmp) =
    fun (x1 : nat) ->
      fun (x2 : nat) ->
        match x1 binding x1 with
        | O -> (match x2 binding x2 with
                | O -> EQ
                | S -> LT)
        | S -> (match x2 binding x2 with
                | O -> GT
                | S -> compare x1 x2)
;;

type natoption =
  | None
  | Some of nat

struct
  type bst = mu bst .
    | Leaf
    | Node of (bst * nat * bst)

  type t = bst

  let empty = Leaf ;;

  let length =
    fix (length : t -> nat) =
      fun (b : t) ->
        match b binding b with
        | Leaf -> O
        | Node -> add (S O) (add (length b.0) (length b.2))
  ;;

  let lookup =
    fix (lookup : t -> nat -> bool) =
      fun (b : t) ->
        fun (x : nat) ->
          match b binding b with
          | Leaf -> False
          | Node -> match compare b.1 x binding c with
                    | EQ -> True
                    | LT -> lookup b.0 x
                    | GT -> lookup b.2 x
  ;;

  let insert =
    fix (insert : t -> nat -> t) =
      fun (b : t) ->
        fun (x : nat) ->
          match b binding bp with
          | Leaf -> Node (Leaf, x, Leaf)
          | Node -> (match compare x bp.1 binding c with
                     | LT -> Node ((insert bp.0 x), bp.1, bp.2)
                     | EQ -> b
                     | GT -> Node (bp.0, bp.1, (insert bp.2 x)))
  ;;

  let min_val =
    fix (min_val : t -> nat) =
      fun (b : t) ->
        match b binding b with
        | Leaf -> O
        | Node -> (match b.0 binding bl with
                   | Leaf -> b.1
                   | Node -> min_val b.0)
  ;;

  let delete =
    fix (delete : t -> nat -> t) =
      fun (b : t) ->
        fun (x : nat) ->
          match b binding bp with
          | Leaf -> Leaf
          | Node ->
              (match compare x bp.1 binding c with
               | LT -> Node ((delete bp.0 x), bp.1, bp.2)
               | EQ -> (match bp.0 binding bl with
                        | Leaf -> bp.2
                        | Node ->
                            (match bp.2 binding br with
                             | Leaf -> bp.0
                             | Node -> (fun (m : nat) ->
                                          Node (bp.0, m, (delete bp.2 m)))
                                       (min_val bp.2)))
                | GT -> Node (bp.0, bp.1, (delete bp.2 x)))
  ;;

  let union =
    fix (union : t -> t -> t) =
      fun (bx : t) ->
        fun (by : t) ->
          match bx binding bx with
          | Leaf -> by
          | Node -> (union bx.0 (union bx.2 (insert by bx.1)))
  ;;

  let inter =
    fix (inter : t -> t -> t) =
      fun (bx : t) ->
        fun (by : t) ->
          match bx binding bx with
          | Leaf -> Leaf
          | Node -> (match lookup by bx.1 binding r with
                     | True -> insert (union (inter bx.0 by) (inter bx.2 by)) bx.1
                     | False -> union (inter bx.0 by) (inter bx.2 by))
  ;;
end
:
sig
  type t

  val empty : t

  val length : t -> nat
  val lookup : t -> nat -> bool

  val insert : t -> nat -> t
  val delete : t -> nat -> t

  (*val union : t -> t -> t
  val inter : t -> t -> t*)
end

maintains

forall (s : t) .
  forall (i : nat) .
    forall (j : nat) .
      (and
        (not (lookup (delete s i) i))
        (implies (lookup (delete s i) j)
                 (lookup s j)))

accumulating (natoption * natoption)