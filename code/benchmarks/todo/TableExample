Module Type TABLE.
 Parameter V: Type.
 Parameter default: V.
 Parameter table: Type.
 Definition key := nat.
 Parameter empty: table.
 Parameter get: key → table → V.
 Parameter set: key → V → table → table.
 Axiom gempty: ∀ k, (* get-empty *)
       get k empty = default.
 Axiom gss: ∀ k v t, (* get-set-same *)
      get k (set k v t) = v.
 Axiom gso: ∀ j k v t, (* get-set-other *)
      j ≠ k → get j (set k v t) = get j t.
End TABLE.






Implementation: Total Maps
Definition total_map (A : Type) := string → A.
Definition t_empty {A : Type} (v : A) : total_map A :=
  (fun _ ⇒ v).
Definition t_update {A : Type} (m : total_map A)
                    (x : string) (v : A) :=
  fun x' ⇒ if eqb_string x x' then v else m x'.





Implementation: Search Trees
Section TREES.
Variable V : Type.
Variable default: V.
Definition key := nat.
Inductive tree : Type :=
 | E : tree
 | T: tree → key → V → tree → tree.
Definition empty_tree : tree := E.
Fixpoint lookup (x: key) (t : tree) : V :=
  match t with
  | E ⇒ default
  | T tl k v tr ⇒ if x <? k then lookup x tl
                         else if k <? x then lookup x tr
                         else v
  end.
Fixpoint insert (x: key) (v: V) (s: tree) : tree :=
 match s with
 | E ⇒ T E x v E
 | T a y v' b ⇒ if x <? y then T (insert x v a) y v' b
                        else if y <? x then T a y v' (insert x v b)
                        else T a x v b
 end.
Fixpoint elements' (s: tree) (base: list (key*V)) : list (key * V) :=
 match s with
 | E ⇒ base
 | T a k v b ⇒ elements' a ((k,v) :: elements' b base)
 end.
Definition elements (s: tree) : list (key * V) := elements' s nil.