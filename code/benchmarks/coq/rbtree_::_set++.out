2019-11-17 01:41:05.014927-05:00

2019-11-17 01:41:05.015370-05:00
DSInfer========================================================================
2019-11-17 01:41:05.016677-05:00
Answer list length: 2
2019-11-17 01:41:05.016694-05:00
Candidate invariant: fun (x:rbtree) -> False
2019-11-17 01:41:05.017952-05:00
Checking boundary for:Leaf
2019-11-17 01:41:05.018491-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
                                               Comes from
                                               ()
2019-11-17 01:41:05.018513-05:00
Answer list length: 1
2019-11-17 01:41:05.018519-05:00
Candidate invariant: fun (x:rbtree) -> True
2019-11-17 01:41:05.018813-05:00
Checking boundary for:Leaf
2019-11-17 01:41:05.019267-05:00
Safe
2019-11-17 01:41:05.019272-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:05.019873-05:00
Safe
2019-11-17 01:41:05.027174-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:05.027797-05:00
Safe
2019-11-17 01:41:05.027806-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:05.029779-05:00
Safe
2019-11-17 01:41:05.029787-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:05.056169-05:00
Safe
2019-11-17 01:41:05.056190-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:05.057330-05:00
Safe
2019-11-17 01:41:05.057339-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:05.082761-05:00
Safe
2019-11-17 01:41:05.082784-05:00
verifying proves postcondition
2019-11-17 01:41:08.100279-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:41:08.100380-05:00
testbed
2019-11-17 01:41:08.100386-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests = [(Value.Ctor ("Leaf", (Value.Tuple [])))] }
2019-11-17 01:41:08.258862-05:00
Answer list length: 2
2019-11-17 01:41:08.258886-05:00
Candidate invariant: fun (r1:rbtree) -> nat_lte (size r1) (size empty)
2019-11-17 01:41:08.259267-05:00
Checking boundary for:Leaf
2019-11-17 01:41:08.259877-05:00
Safe
2019-11-17 01:41:08.259885-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:08.260453-05:00
Safe
2019-11-17 01:41:08.260460-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:08.260993-05:00
Safe
2019-11-17 01:41:08.260998-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:08.300996-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:41:08.345080-05:00
Answer list length: 1
2019-11-17 01:41:08.345095-05:00
Candidate invariant: fun (x:rbtree) -> True
2019-11-17 01:41:08.345792-05:00
Checking boundary for:Leaf
2019-11-17 01:41:08.346546-05:00
Safe
2019-11-17 01:41:08.346552-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:08.347157-05:00
Safe
2019-11-17 01:41:08.347163-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:08.348058-05:00
Safe
2019-11-17 01:41:08.348073-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:08.378742-05:00
Safe
2019-11-17 01:41:08.378761-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:08.461503-05:00
Safe
2019-11-17 01:41:08.461518-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:08.462318-05:00
Safe
2019-11-17 01:41:08.462326-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:08.463190-05:00
Safe
2019-11-17 01:41:08.502652-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:41:08.502885-05:00
testbed
2019-11-17 01:41:08.502919-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:41:08.729325-05:00
Answer list length: 2
2019-11-17 01:41:08.729350-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> True)
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:08.729761-05:00
Checking boundary for:Leaf
2019-11-17 01:41:08.730334-05:00
Safe
2019-11-17 01:41:08.730341-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:08.730824-05:00
Safe
2019-11-17 01:41:08.730829-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:08.785479-05:00
Safe
2019-11-17 01:41:08.785486-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:08.845958-05:00
Safe
2019-11-17 01:41:08.845981-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:08.898649-05:00
Safe
2019-11-17 01:41:08.898665-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:08.899457-05:00
Safe
2019-11-17 01:41:08.948404-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:08.949861-05:00
Safe
2019-11-17 01:41:08.949876-05:00
verifying proves postcondition
2019-11-17 01:41:12.134027-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:41:12.134315-05:00
testbed
2019-11-17 01:41:12.134320-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:41:12.197370-05:00
Answer list length: 3
2019-11-17 01:41:12.197391-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> f1 r2)
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:12.241978-05:00
Checking boundary for:Leaf
2019-11-17 01:41:12.243599-05:00
Safe
2019-11-17 01:41:12.243621-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:12.245503-05:00
Safe
2019-11-17 01:41:12.245523-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:12.294911-05:00
Safe
2019-11-17 01:41:12.294926-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:12.298580-05:00
Safe
2019-11-17 01:41:12.298599-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:12.399428-05:00
Safe
2019-11-17 01:41:12.399444-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:12.400215-05:00
Safe
2019-11-17 01:41:12.400223-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:12.450291-05:00
Safe
2019-11-17 01:41:12.450304-05:00
verifying proves postcondition
2019-11-17 01:41:15.646488-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:41:15.648701-05:00
testbed
2019-11-17 01:41:15.648714-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:41:15.854866-05:00
Answer list length: 4
2019-11-17 01:41:15.854890-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> lookup r1
                                                                    (size r2))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:15.855275-05:00
Checking boundary for:Leaf
2019-11-17 01:41:15.855793-05:00
Safe
2019-11-17 01:41:15.855799-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:15.861636-05:00
Safe
2019-11-17 01:41:15.861646-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:15.862451-05:00
Safe
2019-11-17 01:41:15.862457-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:15.913513-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:41:15.914005-05:00
Answer list length: 3
2019-11-17 01:41:15.914016-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> f1 r2)
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:15.966651-05:00
Checking boundary for:Leaf
2019-11-17 01:41:15.967550-05:00
Safe
2019-11-17 01:41:15.967561-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:15.968324-05:00
Safe
2019-11-17 01:41:15.968347-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:16.021673-05:00
Safe
2019-11-17 01:41:16.021691-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:16.076785-05:00
Safe
2019-11-17 01:41:16.076810-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:16.131435-05:00
Safe
2019-11-17 01:41:16.131458-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:16.132612-05:00
Safe
2019-11-17 01:41:16.132620-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:16.184543-05:00
Safe
2019-11-17 01:41:16.184560-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:41:16.238608-05:00
testbed
2019-11-17 01:41:16.238623-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:41:16.361820-05:00
Answer list length: 4
2019-11-17 01:41:16.361839-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> nat_lte
                                                                    (size r2)
                                                                    n1)
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:16.395978-05:00
Checking boundary for:Leaf
2019-11-17 01:41:16.396654-05:00
Safe
2019-11-17 01:41:16.396660-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:16.397297-05:00
Safe
2019-11-17 01:41:16.397307-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:16.447812-05:00
Safe
2019-11-17 01:41:16.447832-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:16.453780-05:00
Safe
2019-11-17 01:41:16.453794-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:16.564195-05:00
Safe
2019-11-17 01:41:16.564210-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:16.565530-05:00
Safe
2019-11-17 01:41:16.565543-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:16.612460-05:00
Safe
2019-11-17 01:41:16.612477-05:00
verifying proves postcondition
2019-11-17 01:41:19.891150-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:41:19.895262-05:00
testbed
2019-11-17 01:41:19.895276-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:41:20.238069-05:00
Answer list length: 5
2019-11-17 01:41:20.238096-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> nat_eq
                                                                    (size r3)
                                                                    (size r2))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:20.238529-05:00
Checking boundary for:Leaf
2019-11-17 01:41:20.239101-05:00
Safe
2019-11-17 01:41:20.239107-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:20.293662-05:00
Safe
2019-11-17 01:41:20.293684-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:20.294785-05:00
Safe
2019-11-17 01:41:20.294797-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:20.347600-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:41:20.402277-05:00
Answer list length: 4
2019-11-17 01:41:20.402296-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> nat_lte
                                                                    (size r2)
                                                                    n1)
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:20.454612-05:00
Checking boundary for:Leaf
2019-11-17 01:41:20.455555-05:00
Safe
2019-11-17 01:41:20.455564-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:20.456448-05:00
Safe
2019-11-17 01:41:20.456456-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:20.457381-05:00
Safe
2019-11-17 01:41:20.457389-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:20.520891-05:00
Safe
2019-11-17 01:41:20.520912-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:20.621589-05:00
Safe
2019-11-17 01:41:20.621611-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:20.622837-05:00
Safe
2019-11-17 01:41:20.622844-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:20.666134-05:00
Safe
2019-11-17 01:41:20.666147-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:41:20.669062-05:00
testbed
2019-11-17 01:41:20.669074-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:41:21.270505-05:00
Answer list length: 5
2019-11-17 01:41:21.270548-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> not
                                                                    (lookup
                                                                    (delete
                                                                    r1 n1) n1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:21.271139-05:00
Checking boundary for:Leaf
2019-11-17 01:41:21.271884-05:00
Safe
2019-11-17 01:41:21.325662-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:21.326600-05:00
Safe
2019-11-17 01:41:21.326611-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:21.327305-05:00
Safe
2019-11-17 01:41:21.327311-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:21.404534-05:00
Safe
2019-11-17 01:41:21.404558-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:21.447588-05:00
Safe
2019-11-17 01:41:21.447605-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:21.487691-05:00
Safe
2019-11-17 01:41:21.487701-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:21.489575-05:00
Safe
2019-11-17 01:41:21.489584-05:00
verifying proves postcondition
2019-11-17 01:41:38.401586-05:00
postcondition proven
2019-11-17 01:41:38.401630-05:00
verifying: Leaf
2019-11-17 01:41:38.402736-05:00
Safe
2019-11-17 01:41:38.402743-05:00
verifying: fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:38.403481-05:00
Safe
2019-11-17 01:41:38.403487-05:00
verifying: fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:38.404128-05:00
Safe
2019-11-17 01:41:38.404134-05:00
verifying: fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:43.685375-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"S\",\n                           (Value.Ctor (\"O\", (Value.Tuple [])))));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"S\",\n                           (Value.Ctor (\"O\", (Value.Tuple [])))));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:41:43.745308-05:00
testbed
2019-11-17 01:41:43.745326-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:41:44.365226-05:00
Answer list length: 6
2019-11-17 01:41:44.365267-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> not
                                                                    (lookup
                                                                    (union r3
                                                                    r2) n1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:41:44.365676-05:00
Checking boundary for:Leaf
2019-11-17 01:41:44.366653-05:00
Safe
2019-11-17 01:41:44.417455-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:41:44.418644-05:00
Safe
2019-11-17 01:41:44.418657-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:41:44.419466-05:00
Safe
2019-11-17 01:41:44.419474-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:41:44.463226-05:00
Safe
2019-11-17 01:41:44.463249-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:41:44.513845-05:00
Safe
2019-11-17 01:41:44.513864-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:41:44.545536-05:00
Safe
2019-11-17 01:41:44.545548-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:41:44.547818-05:00
Safe
2019-11-17 01:41:44.547828-05:00
verifying proves postcondition
2019-11-17 01:42:00.916654-05:00
postcondition proven
2019-11-17 01:42:00.916682-05:00
verifying: Leaf
2019-11-17 01:42:00.917389-05:00
Safe
2019-11-17 01:42:00.917395-05:00
verifying: fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:42:00.917969-05:00
Safe
2019-11-17 01:42:00.917975-05:00
verifying: fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:42:00.918690-05:00
Safe
2019-11-17 01:42:00.918696-05:00
verifying: fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:42:11.109337-05:00
Safe
2019-11-17 01:42:11.109360-05:00
verifying: fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:42:11.217417-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:42:11.245900-05:00
testbed
2019-11-17 01:42:11.245916-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:42:14.018384-05:00
Answer list length: 7
2019-11-17 01:42:14.018424-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> and
                                                                    (f1 r3)
                                                                    (nat_lte
                                                                    (size r2)
                                                                    n1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:42:14.018862-05:00
Checking boundary for:Leaf
2019-11-17 01:42:14.077523-05:00
Safe
2019-11-17 01:42:14.077535-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:42:14.078614-05:00
Safe
2019-11-17 01:42:14.078623-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:42:14.079693-05:00
Safe
2019-11-17 01:42:14.079702-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:42:14.150326-05:00
Safe
2019-11-17 01:42:14.150344-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:42:14.292662-05:00
Safe
2019-11-17 01:42:14.292684-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:42:14.294130-05:00
Safe
2019-11-17 01:42:14.294137-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:42:14.295529-05:00
Safe
2019-11-17 01:42:14.295536-05:00
verifying proves postcondition
2019-11-17 01:42:17.366352-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:42:17.374531-05:00
testbed
2019-11-17 01:42:17.374578-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:42:42.644053-05:00
Answer list length: 8
2019-11-17 01:42:42.644100-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match union r3 r2 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_2 -> 
                                                                    False
                                                                    | Black N_fresh_var_2 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    and
                                                                    (lookup
                                                                    r3
                                                                    (size r3))
                                                                    (f1 r3))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:42:42.784756-05:00
Checking boundary for:Leaf
2019-11-17 01:42:42.786184-05:00
Safe
2019-11-17 01:42:42.786197-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:42:42.787309-05:00
Safe
2019-11-17 01:42:42.787320-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:42:42.856778-05:00
Safe
2019-11-17 01:42:42.856794-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:42:42.863413-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\",\n                   (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:42:42.935138-05:00
Answer list length: 7
2019-11-17 01:42:42.935163-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> and
                                                                    (f1 r3)
                                                                    (nat_lte
                                                                    (size r2)
                                                                    n1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:42:43.026203-05:00
Checking boundary for:Leaf
2019-11-17 01:42:43.027040-05:00
Safe
2019-11-17 01:42:43.027048-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:42:43.097020-05:00
Safe
2019-11-17 01:42:43.097028-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:42:43.097808-05:00
Safe
2019-11-17 01:42:43.097816-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:42:43.196366-05:00
Safe
2019-11-17 01:42:43.196386-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:42:43.261771-05:00
Safe
2019-11-17 01:42:43.261794-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:42:43.294385-05:00
Safe
2019-11-17 01:42:43.294398-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:42:43.296083-05:00
Safe
2019-11-17 01:42:43.296098-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:42:43.435980-05:00
Answer list length: 8
2019-11-17 01:42:43.436011-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 (min_val r1) with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_2 -> 
                                                                    False
                                                                    | Black N_fresh_var_2 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    and
                                                                    (nat_lt
                                                                    n1 n2)
                                                                    (f1 r3))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:42:43.521630-05:00
Checking boundary for:Leaf
2019-11-17 01:42:43.523025-05:00
Safe
2019-11-17 01:42:43.523038-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:42:43.523928-05:00
Safe
2019-11-17 01:42:43.595654-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:42:43.597570-05:00
Safe
2019-11-17 01:42:43.597598-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:42:43.686305-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:42:43.744194-05:00
Answer list length: 7
2019-11-17 01:42:43.744215-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> and
                                                                    (f1 r3)
                                                                    (nat_lte
                                                                    (size r2)
                                                                    n1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:42:43.815222-05:00
Checking boundary for:Leaf
2019-11-17 01:42:43.816370-05:00
Safe
2019-11-17 01:42:43.816380-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:42:43.817316-05:00
Safe
2019-11-17 01:42:43.817330-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:42:43.818279-05:00
Safe
2019-11-17 01:42:43.890515-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:42:43.915551-05:00
Safe
2019-11-17 01:42:43.915571-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:42:44.097792-05:00
Safe
2019-11-17 01:42:44.097818-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:42:44.099416-05:00
Safe
2019-11-17 01:42:44.099431-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:42:44.163827-05:00
Safe
2019-11-17 01:42:44.163843-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:42:44.169014-05:00
testbed
2019-11-17 01:42:44.169039-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:43:28.968603-05:00
Answer list length: 8
2019-11-17 01:43:28.968634-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 (min_val r1) with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    nat_lte
                                                                    n1
                                                                    (size r1))
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match c2 with
                                                                    | Red N_fresh_var_2 -> 
                                                                    False
                                                                    | Black N_fresh_var_2 -> 
                                                                    nat_lt
                                                                    (size
                                                                    empty) n2)
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:43:29.106759-05:00
Checking boundary for:Leaf
2019-11-17 01:43:29.107849-05:00
Safe
2019-11-17 01:43:29.107861-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:43:29.108633-05:00
Safe
2019-11-17 01:43:29.108646-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:43:29.178493-05:00
Safe
2019-11-17 01:43:29.178501-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:43:29.244887-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\",\n           (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:43:29.248772-05:00
Answer list length: 7
2019-11-17 01:43:29.248789-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match c1 with
                                          | Red N_fresh_var_1 -> False
                                          | Black N_fresh_var_1 -> and
                                                                    (f1 r3)
                                                                    (nat_lte
                                                                    (size r2)
                                                                    n1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:43:29.506793-05:00
Checking boundary for:Leaf
2019-11-17 01:43:29.507924-05:00
Safe
2019-11-17 01:43:29.507936-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:43:29.575871-05:00
Safe
2019-11-17 01:43:29.575882-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:43:29.576678-05:00
Safe
2019-11-17 01:43:29.576685-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:43:29.672242-05:00
Safe
2019-11-17 01:43:29.672283-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:43:29.735524-05:00
Safe
2019-11-17 01:43:29.735545-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:43:29.791108-05:00
Safe
2019-11-17 01:43:29.791133-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:43:29.793209-05:00
Safe
2019-11-17 01:43:29.793218-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:43:30.030346-05:00
testbed
2019-11-17 01:43:30.030373-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:44:03.612645-05:00
Answer list length: 8
2019-11-17 01:44:03.612677-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 (min_val r1) with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_2 -> 
                                                                    False
                                                                    | Black N_fresh_var_2 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    and
                                                                    (nat_lt
                                                                    (size
                                                                    empty) n2)
                                                                    (f1 r3))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:44:03.687147-05:00
Checking boundary for:Leaf
2019-11-17 01:44:03.688670-05:00
Safe
2019-11-17 01:44:03.688684-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:44:03.689617-05:00
Safe
2019-11-17 01:44:03.689625-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:44:03.759644-05:00
Safe
2019-11-17 01:44:03.759668-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:44:03.846231-05:00
Safe
2019-11-17 01:44:03.846251-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:44:03.933054-05:00
Safe
2019-11-17 01:44:03.933074-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:44:03.936175-05:00
Safe
2019-11-17 01:44:03.936184-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:44:03.970133-05:00
Safe
2019-11-17 01:44:03.970152-05:00
verifying proves postcondition
2019-11-17 01:44:07.588695-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:44:07.629594-05:00
testbed
2019-11-17 01:44:07.629613-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:44:42.106295-05:00
Answer list length: 9
2019-11-17 01:44:42.106325-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 (min_val r1) with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_2 -> 
                                                                    False
                                                                    | Black N_fresh_var_2 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    and
                                                                    (nat_lt
                                                                    (min_val
                                                                    r1) n2)
                                                                    (f1 r3))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:44:42.243324-05:00
Checking boundary for:Leaf
2019-11-17 01:44:42.245418-05:00
Safe
2019-11-17 01:44:42.245437-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:44:42.246645-05:00
Safe
2019-11-17 01:44:42.246655-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:44:42.310912-05:00
Safe
2019-11-17 01:44:42.310922-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:44:42.469956-05:00
Safe
2019-11-17 01:44:42.469989-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:44:52.625187-05:00
Safe
2019-11-17 01:44:52.625209-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:44:52.628901-05:00
Safe
2019-11-17 01:44:52.628915-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:44:55.540679-05:00
Safe
2019-11-17 01:44:55.540697-05:00
verifying proves postcondition
2019-11-17 01:45:15.976668-05:00
postcondition proven
2019-11-17 01:45:15.976693-05:00
verifying: Leaf
2019-11-17 01:45:15.977344-05:00
Safe
2019-11-17 01:45:15.977350-05:00
verifying: fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:45:15.977845-05:00
Safe
2019-11-17 01:45:15.977850-05:00
verifying: fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:45:15.978658-05:00
Safe
2019-11-17 01:45:15.978673-05:00
verifying: fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:45:33.848155-05:00
Safe
2019-11-17 01:45:33.848188-05:00
verifying: fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:45:33.961258-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:45:44.120761-05:00
testbed
2019-11-17 01:45:44.120781-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:47:23.599966-05:00
Answer list length: 10
2019-11-17 01:47:23.599995-05:00
Candidate invariant: fun (r1:rbtree) ->
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 n1 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match c2 with
                                                                    | Red N_fresh_var_2 -> 
                                                                    False
                                                                    | Black N_fresh_var_2 -> 
                                                                    not
                                                                    (nat_eq
                                                                    (min_val
                                                                    r3) n1))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:47:34.027702-05:00
Checking boundary for:Leaf
2019-11-17 01:47:34.029256-05:00
Safe
2019-11-17 01:47:34.029268-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:47:34.029980-05:00
Safe
2019-11-17 01:47:34.029989-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:47:44.229420-05:00
Safe
2019-11-17 01:47:44.229427-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:47:54.476366-05:00
Safe
2019-11-17 01:47:54.476387-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:48:01.254510-05:00
Safe
2019-11-17 01:48:01.254529-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:48:01.257126-05:00
Safe
2019-11-17 01:48:01.484567-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:48:01.488463-05:00
Safe
2019-11-17 01:48:01.488494-05:00
verifying proves postcondition
2019-11-17 01:48:05.051644-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:48:11.617402-05:00
Answer list length: 11
2019-11-17 01:48:11.617443-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match add n1 (min_val r3) with
                                          | O N_fresh_var_1 -> (match c1 with
                                                                  | Red N_fresh_var_3 -> 
                                                                    False
                                                                  | Black N_fresh_var_3 -> 
                                                                    nat_eq
                                                                    (size r3)
                                                                    (size r2))
                                          | S N_fresh_var_1 -> (fun (n2:unit) ->
                                                                  match c1 with
                                                                    | Red N_fresh_var_2 -> 
                                                                    False
                                                                    | Black N_fresh_var_2 -> 
                                                                    and
                                                                    (f1 r3)
                                                                    (f1 r2))
                                                                 N_fresh_var_1)
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:48:20.763595-05:00
Checking boundary for:Leaf
2019-11-17 01:48:20.764840-05:00
Safe
2019-11-17 01:48:20.764855-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:48:20.765606-05:00
Safe
2019-11-17 01:48:20.765619-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:48:20.839207-05:00
Safe
2019-11-17 01:48:20.839240-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:48:20.903515-05:00
Safe
2019-11-17 01:48:20.918403-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:48:21.021592-05:00
Safe
2019-11-17 01:48:21.021653-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:48:21.025657-05:00
Safe
2019-11-17 01:48:21.025672-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:48:21.073382-05:00
Safe
2019-11-17 01:48:21.073399-05:00
verifying proves postcondition
2019-11-17 01:48:26.246596-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:48:26.258522-05:00
testbed
2019-11-17 01:48:26.258542-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:51:28.736698-05:00
Answer list length: 12
2019-11-17 01:51:28.736727-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 n1 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match 
                                                                    min_val
                                                                    r3 with
                                                                    | O N_fresh_var_2 -> 
                                                                    and
                                                                    (nat_lt
                                                                    n2 n1)
                                                                    (f1 r2)
                                                                    | S N_fresh_var_2 -> 
                                                                    (fun (n3:unit) ->
                                                                    f1 r3)
                                                                    N_fresh_var_2)
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:51:39.032150-05:00
Checking boundary for:Leaf
2019-11-17 01:51:49.320345-05:00
Safe
2019-11-17 01:51:49.320382-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:51:49.321280-05:00
Safe
2019-11-17 01:51:49.321288-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:51:49.321991-05:00
Safe
2019-11-17 01:51:49.321998-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:51:59.604215-05:00
Safe
2019-11-17 01:51:59.604239-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:52:14.361053-05:00
Safe
2019-11-17 01:52:14.361074-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:52:14.364310-05:00
Safe
2019-11-17 01:52:14.364321-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:52:14.366791-05:00
Safe
2019-11-17 01:52:14.366801-05:00
verifying proves postcondition
2019-11-17 01:52:17.380941-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-17 01:52:35.672762-05:00
Answer list length: 13
2019-11-17 01:52:35.672794-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 n1 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match r2 with
                                                                    | Leaf N_fresh_var_2 -> 
                                                                    and
                                                                    (nat_lt
                                                                    n1 n2)
                                                                    (f1 r3)
                                                                    | Node N_fresh_var_2 -> 
                                                                    (fun (c3:unit) ->
                                                                    (fun (r6:unit) ->
                                                                    (fun (n3:unit) ->
                                                                    (fun (r7:unit) ->
                                                                    and
                                                                    (nat_lt
                                                                    n2 n1)
                                                                    (f1 r2))
                                                                    (#4
                                                                    N_fresh_var_2))
                                                                    (#3
                                                                    N_fresh_var_2))
                                                                    (#2
                                                                    N_fresh_var_2))
                                                                    (#1
                                                                    N_fresh_var_2))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:52:35.866590-05:00
Checking boundary for:Leaf
2019-11-17 01:52:35.869402-05:00
Safe
2019-11-17 01:52:35.869416-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:52:46.174351-05:00
Safe
2019-11-17 01:52:46.174361-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:52:46.175150-05:00
Safe
2019-11-17 01:52:46.175191-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:52:56.477403-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\",\n                   (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:53:01.169231-05:00
Answer list length: 12
2019-11-17 01:53:01.169254-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 n1 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match 
                                                                    min_val
                                                                    r3 with
                                                                    | O N_fresh_var_2 -> 
                                                                    and
                                                                    (nat_lt
                                                                    n2 n1)
                                                                    (f1 r2)
                                                                    | S N_fresh_var_2 -> 
                                                                    (fun (n3:unit) ->
                                                                    f1 r3)
                                                                    N_fresh_var_2)
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:53:01.380839-05:00
Checking boundary for:Leaf
2019-11-17 01:53:01.382700-05:00
Safe
2019-11-17 01:53:01.382735-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:53:01.457900-05:00
Safe
2019-11-17 01:53:01.457909-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:53:01.458716-05:00
Safe
2019-11-17 01:53:01.458724-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:53:01.635752-05:00
Safe
2019-11-17 01:53:01.635772-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:53:01.712824-05:00
Safe
2019-11-17 01:53:01.712852-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:53:01.717410-05:00
Safe
2019-11-17 01:53:01.717438-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:53:01.743025-05:00
Safe
2019-11-17 01:53:01.743041-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Red\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:53:01.879689-05:00
Answer list length: 13
2019-11-17 01:53:01.879717-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 n1 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match r3 with
                                                                    | Leaf N_fresh_var_2 -> 
                                                                    and
                                                                    (nat_lt
                                                                    n2 n1)
                                                                    (f1 r2)
                                                                    | Node N_fresh_var_2 -> 
                                                                    (fun (c3:unit) ->
                                                                    (fun (r6:unit) ->
                                                                    (fun (n3:unit) ->
                                                                    (fun (r7:unit) ->
                                                                    and
                                                                    (nat_lt
                                                                    n1 n2)
                                                                    (f1 r3))
                                                                    (#4
                                                                    N_fresh_var_2))
                                                                    (#3
                                                                    N_fresh_var_2))
                                                                    (#2
                                                                    N_fresh_var_2))
                                                                    (#1
                                                                    N_fresh_var_2))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:53:02.038442-05:00
Checking boundary for:Leaf
2019-11-17 01:53:02.105341-05:00
Safe
2019-11-17 01:53:02.105359-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:53:02.106421-05:00
Safe
2019-11-17 01:53:02.106429-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:53:02.107221-05:00
Safe
2019-11-17 01:53:02.107232-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:53:02.303236-05:00
Safe
2019-11-17 01:53:02.303259-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:53:02.369041-05:00
Safe
2019-11-17 01:53:02.369062-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:53:02.372761-05:00
Safe
2019-11-17 01:53:02.372770-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:53:02.403504-05:00
Safe
2019-11-17 01:53:02.403531-05:00
verifying proves postcondition
2019-11-17 01:53:19.727135-05:00
postcondition proven
2019-11-17 01:53:19.727190-05:00
verifying: Leaf
2019-11-17 01:53:19.728402-05:00
Safe
2019-11-17 01:53:19.728411-05:00
verifying: fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:53:19.729060-05:00
Safe
2019-11-17 01:53:19.729067-05:00
verifying: fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:53:19.729718-05:00
Safe
2019-11-17 01:53:19.729724-05:00
verifying: fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:53:31.906781-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"O\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ));\n                (Value.Ctor (\"S\",\n                   (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"O\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ));\n                (Value.Ctor (\"S\",\n                   (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:53:50.562361-05:00
Answer list length: 14
2019-11-17 01:53:50.562397-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 (min_val r1) with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match n1 with
                                                                    | O N_fresh_var_2 -> 
                                                                    and
                                                                    (nat_lt
                                                                    n1 n2)
                                                                    (f1 r3)
                                                                    | S N_fresh_var_2 -> 
                                                                    (fun (n3:unit) ->
                                                                    and
                                                                    (lookup
                                                                    r1 n3)
                                                                    (f1 r2))
                                                                    N_fresh_var_2)
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:54:19.713414-05:00
Checking boundary for:Leaf
2019-11-17 01:54:19.714260-05:00
Safe
2019-11-17 01:54:19.714267-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:54:19.714836-05:00
Safe
2019-11-17 01:54:19.714845-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:54:19.871099-05:00
Safe
2019-11-17 01:54:19.871121-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:54:19.896144-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\",\n                   (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:54:30.354100-05:00
Answer list length: 13
2019-11-17 01:54:30.354125-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 n1 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match r3 with
                                                                    | Leaf N_fresh_var_2 -> 
                                                                    and
                                                                    (nat_lt
                                                                    n2 n1)
                                                                    (f1 r2)
                                                                    | Node N_fresh_var_2 -> 
                                                                    (fun (c3:unit) ->
                                                                    (fun (r6:unit) ->
                                                                    (fun (n3:unit) ->
                                                                    (fun (r7:unit) ->
                                                                    and
                                                                    (nat_lt
                                                                    n1 n2)
                                                                    (f1 r3))
                                                                    (#4
                                                                    N_fresh_var_2))
                                                                    (#3
                                                                    N_fresh_var_2))
                                                                    (#2
                                                                    N_fresh_var_2))
                                                                    (#1
                                                                    N_fresh_var_2))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:54:54.012328-05:00
Checking boundary for:Leaf
2019-11-17 01:54:54.013455-05:00
Safe
2019-11-17 01:54:54.013465-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:54:54.014354-05:00
Safe
2019-11-17 01:54:59.852104-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:54:59.853832-05:00
Safe
2019-11-17 01:54:59.853843-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:55:00.120332-05:00
Safe
2019-11-17 01:55:00.120362-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:55:00.256761-05:00
Safe
2019-11-17 01:55:00.256781-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:55:00.260972-05:00
Safe
2019-11-17 01:55:00.260982-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:55:00.267724-05:00
Safe
2019-11-17 01:55:00.267743-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"O\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ));\n                (Value.Ctor (\"S\",\n                   (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:55:00.397335-05:00
testbed
2019-11-17 01:55:00.397355-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 01:58:33.951051-05:00
Answer list length: 14
2019-11-17 01:58:33.955565-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match min_max_vals r3 r2 with
                                          | JustLeft N_fresh_var_1 -> 
                                            (fun (n2:unit) ->
                                               and (nat_lt n1 n2) (f1 r3))
                                              N_fresh_var_1
                                          | JustRight N_fresh_var_1 -> 
                                            (fun (n2:unit) ->
                                               match f1 r2 with
                                                 | False N_fresh_var_3 -> 
                                                   False
                                                 | True N_fresh_var_3 -> 
                                                   nat_between n2 n1
                                                     (size r1))
                                              N_fresh_var_1
                                          | Both N_fresh_var_1 -> (fun (n2:unit) ->
                                                                    (fun (n3:unit) ->
                                                                    True)
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1)
                                          | Neither N_fresh_var_1 -> (
                                            match c1 with
                                              | Red N_fresh_var_2 -> False
                                              | Black N_fresh_var_2 -> True))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:58:55.254922-05:00
Checking boundary for:Leaf
2019-11-17 01:58:55.291327-05:00
Safe
2019-11-17 01:58:55.291827-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:58:55.428522-05:00
Safe
2019-11-17 01:58:55.428539-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:58:55.629895-05:00
Safe
2019-11-17 01:58:55.629911-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:58:55.658071-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"S\",\n           (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\",\n           (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-17 01:58:55.753136-05:00
Answer list length: 13
2019-11-17 01:58:55.753160-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match delete r1 n1 with
                                          | Leaf N_fresh_var_1 -> (match c1 with
                                                                    | Red N_fresh_var_3 -> 
                                                                    False
                                                                    | Black N_fresh_var_3 -> 
                                                                    True)
                                          | Node N_fresh_var_1 -> (fun (c2:unit) ->
                                                                    (fun (r4:unit) ->
                                                                    (fun (n2:unit) ->
                                                                    (fun (r5:unit) ->
                                                                    match r3 with
                                                                    | Leaf N_fresh_var_2 -> 
                                                                    and
                                                                    (nat_lt
                                                                    n2 n1)
                                                                    (f1 r2)
                                                                    | Node N_fresh_var_2 -> 
                                                                    (fun (c3:unit) ->
                                                                    (fun (r6:unit) ->
                                                                    (fun (n3:unit) ->
                                                                    (fun (r7:unit) ->
                                                                    and
                                                                    (nat_lt
                                                                    n1 n2)
                                                                    (f1 r3))
                                                                    (#4
                                                                    N_fresh_var_2))
                                                                    (#3
                                                                    N_fresh_var_2))
                                                                    (#2
                                                                    N_fresh_var_2))
                                                                    (#1
                                                                    N_fresh_var_2))
                                                                    (#4
                                                                    N_fresh_var_1))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 01:58:56.034494-05:00
Checking boundary for:Leaf
2019-11-17 01:58:56.035574-05:00
Safe
2019-11-17 01:58:56.035581-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 01:58:56.068477-05:00
Safe
2019-11-17 01:58:56.068489-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 01:58:56.070313-05:00
Safe
2019-11-17 01:58:56.070325-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 01:58:56.330279-05:00
Safe
2019-11-17 01:58:56.330305-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 01:58:56.480298-05:00
Safe
2019-11-17 01:58:56.480319-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 01:58:56.484969-05:00
Safe
2019-11-17 01:58:56.484984-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 01:58:56.487910-05:00
Safe
2019-11-17 01:58:56.487923-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"O\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ));\n                (Value.Ctor (\"S\",\n                   (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 01:59:05.395659-05:00
testbed
2019-11-17 01:59:05.395684-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-17 02:06:27.450549-05:00
Answer list length: 14
2019-11-17 02:06:27.454648-05:00
Candidate invariant: fix f1 (r1:rbtree) : bool =
  match r1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (c1:unit) ->
                               (fun (r2:unit) ->
                                  (fun (n1:unit) ->
                                     (fun (r3:unit) ->
                                        match min_max_vals r3 r2 with
                                          | JustLeft N_fresh_var_1 -> 
                                            (fun (n2:unit) ->
                                               and (nat_lt n1 n2) (f1 r3))
                                              N_fresh_var_1
                                          | JustRight N_fresh_var_1 -> 
                                            (fun (n2:unit) ->
                                               match c1 with
                                                 | Red N_fresh_var_3 -> False
                                                 | Black N_fresh_var_3 -> 
                                                   and (nat_lt n2 n1) (
                                                     f1 r2))
                                              N_fresh_var_1
                                          | Both N_fresh_var_1 -> (fun (n2:unit) ->
                                                                    (fun (n3:unit) ->
                                                                    True)
                                                                    (#2
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #1
                                                                    N_fresh_var_1)
                                          | Neither N_fresh_var_1 -> (
                                            match c1 with
                                              | Red N_fresh_var_2 -> False
                                              | Black N_fresh_var_2 -> True))
                                       (#4 N_fresh_var_0))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-17 02:06:31.444246-05:00
Checking boundary for:Leaf
2019-11-17 02:06:31.480668-05:00
Safe
2019-11-17 02:06:31.480708-05:00
Checking boundary for:fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 02:06:31.486329-05:00
Safe
2019-11-17 02:06:31.486341-05:00
Checking boundary for:fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 02:06:31.568699-05:00
Safe
2019-11-17 02:06:31.568722-05:00
Checking boundary for:fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 02:06:31.687373-05:00
Safe
2019-11-17 02:06:31.687419-05:00
Checking boundary for:fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 02:06:31.780654-05:00
Safe
2019-11-17 02:06:31.780678-05:00
Checking boundary for:fix union (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#2 bx) (union (#4 bx) (insert by (#3 bx)))
2019-11-17 02:06:31.786072-05:00
Safe
2019-11-17 02:06:31.786096-05:00
Checking boundary for:fix inter (bx:rbtree) : rbtree -> rbtree =
  fun (by:rbtree) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#3 bx) with
                      | True r -> insert
                                    (union (inter (#2 bx) by)
                                       (inter (#4 bx) by))
                                    (#3 bx)
                      | False r -> union (inter (#2 bx) by)
                                     (inter (#4 bx) by))
2019-11-17 02:06:31.808577-05:00
Safe
2019-11-17 02:06:31.808602-05:00
verifying proves postcondition
2019-11-17 02:07:04.928515-05:00
postcondition proven
2019-11-17 02:07:04.928544-05:00
verifying: Leaf
2019-11-17 02:07:04.934027-05:00
Safe
2019-11-17 02:07:04.934036-05:00
verifying: fix size (b:rbtree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#2 b)) (size (#4 b)))
2019-11-17 02:07:04.937226-05:00
Safe
2019-11-17 02:07:04.937238-05:00
verifying: fix lookup (b:rbtree) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#3 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#3 b) with
                                     | True c -> lookup (#2 b) x
                                     | False c -> lookup (#4 b) x))
2019-11-17 02:07:04.938883-05:00
Safe
2019-11-17 02:07:04.938895-05:00
verifying: fix insert (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Black, Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#3 bp) with
                      | True c -> Node (Black, insert (#2 bp) x, #3 bp,
                                         #4 bp)
                      | False c -> (match nat_eq x (#3 bp) with
                                      | True c -> b
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          insert (#4 bp) x)))
2019-11-17 02:07:27.826766-05:00
Safe
2019-11-17 02:07:27.826906-05:00
verifying: fix delete (b:rbtree) : nat -> rbtree =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#3 bp) with
                      | True c -> (match #2 bp with
                                     | Leaf bl -> #4 bp
                                     | Node bl -> (match #4 bp with
                                                     | Leaf br -> #2 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (Black,
                                                                    #2 bp, m,
                                                                    delete
                                                                    (#4 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#4 bp))))
                      | False c -> (match nat_lt x (#3 bp) with
                                      | True c -> Node (Black,
                                                         delete (#2 bp) x,
                                                         #3 bp, #4 bp)
                                      | False c -> Node (Black, #2 bp, 
                                                          #3 bp,
                                                          delete (#4 bp) x)))
2019-11-17 02:07:29.566881-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Black\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Red\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-17 02:09:00.175133-05:00
testbed
2019-11-17 02:09:00.175844-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Red", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Black", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("S",
                               (Value.Ctor ("O", (Value.Tuple [])))));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Red", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Red", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Black", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Black", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S",
                       (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                          ))
                       ));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Black", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Black", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
interrupt: 2
