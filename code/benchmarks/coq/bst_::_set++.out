2019-11-16 15:37:29.049238-05:00

2019-11-16 15:37:29.049660-05:00
DSInfer========================================================================
2019-11-16 15:37:29.050763-05:00
Answer list length: 2
2019-11-16 15:37:29.050778-05:00
Candidate invariant: fun (x:bst) -> False
2019-11-16 15:37:29.051931-05:00
Checking boundary for:Leaf
2019-11-16 15:37:29.052506-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
                                               Comes from
                                               ()
2019-11-16 15:37:29.052530-05:00
Answer list length: 1
2019-11-16 15:37:29.052536-05:00
Candidate invariant: fun (x:bst) -> True
2019-11-16 15:37:29.052883-05:00
Checking boundary for:Leaf
2019-11-16 15:37:29.053469-05:00
Safe
2019-11-16 15:37:29.053479-05:00
Checking boundary for:fix size (b:bst) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#1 b)) (size (#3 b)))
2019-11-16 15:37:29.054043-05:00
Safe
2019-11-16 15:37:29.068312-05:00
Checking boundary for:fix lookup (b:bst) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#2 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#2 b) with
                                     | True c -> lookup (#1 b) x
                                     | False c -> lookup (#3 b) x))
2019-11-16 15:37:29.069064-05:00
Safe
2019-11-16 15:37:29.069070-05:00
Checking boundary for:fix insert (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#2 bp) with
                      | True c -> Node (insert (#1 bp) x, #2 bp, #3 bp)
                      | False c -> (match nat_eq x (#2 bp) with
                                      | True c -> b
                                      | False c -> Node (#1 bp, #2 bp,
                                                          insert (#3 bp) x)))
2019-11-16 15:37:29.070240-05:00
Safe
2019-11-16 15:37:29.070251-05:00
Checking boundary for:fix delete (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#2 bp) with
                      | True c -> (match #1 bp with
                                     | Leaf bl -> #3 bp
                                     | Node bl -> (match #3 bp with
                                                     | Leaf br -> #1 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (#1 bp,
                                                                    m,
                                                                    delete
                                                                    (#3 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#3 bp))))
                      | False c -> (match nat_lt x (#2 bp) with
                                      | True c -> Node (delete (#1 bp) x,
                                                         #2 bp, #3 bp)
                                      | False c -> Node (#1 bp, #2 bp,
                                                          delete (#3 bp) x)))
2019-11-16 15:37:29.098518-05:00
Safe
2019-11-16 15:37:29.098539-05:00
Checking boundary for:fix union (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#1 bx) (union (#3 bx) (insert by (#2 bx)))
2019-11-16 15:37:29.099626-05:00
Safe
2019-11-16 15:37:29.099638-05:00
Checking boundary for:fix inter (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#2 bx) with
                      | True r -> insert
                                    (union (inter (#1 bx) by)
                                       (inter (#3 bx) by))
                                    (#2 bx)
                      | False r -> union (inter (#1 bx) by)
                                     (inter (#3 bx) by))
2019-11-16 15:37:29.121240-05:00
Safe
2019-11-16 15:37:29.121265-05:00
verifying proves postcondition
2019-11-16 15:37:29.287067-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))""(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-16 15:37:29.287172-05:00
testbed
2019-11-16 15:37:29.287176-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests = [(Value.Ctor ("Leaf", (Value.Tuple [])))] }
2019-11-16 15:37:29.331422-05:00
Answer list length: 2
2019-11-16 15:37:29.331448-05:00
Candidate invariant: fun (b1:bst) -> nat_lte (length b1) (length empty)
2019-11-16 15:37:29.331768-05:00
Checking boundary for:Leaf
2019-11-16 15:37:29.332320-05:00
Safe
2019-11-16 15:37:29.332325-05:00
Checking boundary for:fix size (b:bst) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#1 b)) (size (#3 b)))
2019-11-16 15:37:29.332861-05:00
Safe
2019-11-16 15:37:29.332866-05:00
Checking boundary for:fix lookup (b:bst) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#2 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#2 b) with
                                     | True c -> lookup (#1 b) x
                                     | False c -> lookup (#3 b) x))
2019-11-16 15:37:29.333322-05:00
Safe
2019-11-16 15:37:29.333327-05:00
Checking boundary for:fix insert (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#2 bp) with
                      | True c -> Node (insert (#1 bp) x, #2 bp, #3 bp)
                      | False c -> (match nat_eq x (#2 bp) with
                                      | True c -> b
                                      | False c -> Node (#1 bp, #2 bp,
                                                          insert (#3 bp) x)))
2019-11-16 15:37:29.336439-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-16 15:37:29.336497-05:00
Answer list length: 1
2019-11-16 15:37:29.336512-05:00
Candidate invariant: fun (x:bst) -> True
2019-11-16 15:37:29.362981-05:00
Checking boundary for:Leaf
2019-11-16 15:37:29.364099-05:00
Safe
2019-11-16 15:37:29.364111-05:00
Checking boundary for:fix size (b:bst) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#1 b)) (size (#3 b)))
2019-11-16 15:37:29.365249-05:00
Safe
2019-11-16 15:37:29.365260-05:00
Checking boundary for:fix lookup (b:bst) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#2 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#2 b) with
                                     | True c -> lookup (#1 b) x
                                     | False c -> lookup (#3 b) x))
2019-11-16 15:37:29.366243-05:00
Safe
2019-11-16 15:37:29.366250-05:00
Checking boundary for:fix insert (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#2 bp) with
                      | True c -> Node (insert (#1 bp) x, #2 bp, #3 bp)
                      | False c -> (match nat_eq x (#2 bp) with
                                      | True c -> b
                                      | False c -> Node (#1 bp, #2 bp,
                                                          insert (#3 bp) x)))
2019-11-16 15:37:29.393581-05:00
Safe
2019-11-16 15:37:29.393595-05:00
Checking boundary for:fix delete (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#2 bp) with
                      | True c -> (match #1 bp with
                                     | Leaf bl -> #3 bp
                                     | Node bl -> (match #3 bp with
                                                     | Leaf br -> #1 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (#1 bp,
                                                                    m,
                                                                    delete
                                                                    (#3 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#3 bp))))
                      | False c -> (match nat_lt x (#2 bp) with
                                      | True c -> Node (delete (#1 bp) x,
                                                         #2 bp, #3 bp)
                                      | False c -> Node (#1 bp, #2 bp,
                                                          delete (#3 bp) x)))
2019-11-16 15:37:29.418417-05:00
Safe
2019-11-16 15:37:29.418436-05:00
Checking boundary for:fix union (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#1 bx) (union (#3 bx) (insert by (#2 bx)))
2019-11-16 15:37:29.439301-05:00
Safe
2019-11-16 15:37:29.439319-05:00
Checking boundary for:fix inter (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#2 bx) with
                      | True r -> insert
                                    (union (inter (#1 bx) by)
                                       (inter (#3 bx) by))
                                    (#2 bx)
                      | False r -> union (inter (#1 bx) by)
                                     (inter (#3 bx) by))
2019-11-16 15:37:29.440917-05:00
Safe
2019-11-16 15:37:29.440930-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-16 15:37:29.460072-05:00
testbed
2019-11-16 15:37:29.460098-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-16 15:37:29.583815-05:00
Answer list length: 2
2019-11-16 15:37:29.583861-05:00
Candidate invariant: fun (b1:bst) -> nat_eq (length (union b1 empty)) (length b1)
2019-11-16 15:37:29.584261-05:00
Checking boundary for:Leaf
2019-11-16 15:37:29.584877-05:00
Safe
2019-11-16 15:37:29.584885-05:00
Checking boundary for:fix size (b:bst) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#1 b)) (size (#3 b)))
2019-11-16 15:37:29.585378-05:00
Safe
2019-11-16 15:37:29.585383-05:00
Checking boundary for:fix lookup (b:bst) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#2 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#2 b) with
                                     | True c -> lookup (#1 b) x
                                     | False c -> lookup (#3 b) x))
2019-11-16 15:37:29.585943-05:00
Safe
2019-11-16 15:37:29.585948-05:00
Checking boundary for:fix insert (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#2 bp) with
                      | True c -> Node (insert (#1 bp) x, #2 bp, #3 bp)
                      | False c -> (match nat_eq x (#2 bp) with
                                      | True c -> b
                                      | False c -> Node (#1 bp, #2 bp,
                                                          insert (#3 bp) x)))
2019-11-16 15:37:29.639954-05:00
Safe
2019-11-16 15:37:29.639979-05:00
Checking boundary for:fix delete (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#2 bp) with
                      | True c -> (match #1 bp with
                                     | Leaf bl -> #3 bp
                                     | Node bl -> (match #3 bp with
                                                     | Leaf br -> #1 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (#1 bp,
                                                                    m,
                                                                    delete
                                                                    (#3 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#3 bp))))
                      | False c -> (match nat_lt x (#2 bp) with
                                      | True c -> Node (delete (#1 bp) x,
                                                         #2 bp, #3 bp)
                                      | False c -> Node (#1 bp, #2 bp,
                                                          delete (#3 bp) x)))
2019-11-16 15:37:29.684563-05:00
Safe
2019-11-16 15:37:29.684579-05:00
Checking boundary for:fix union (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#1 bx) (union (#3 bx) (insert by (#2 bx)))
2019-11-16 15:37:29.727326-05:00
Safe
2019-11-16 15:37:29.727343-05:00
Checking boundary for:fix inter (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#2 bx) with
                      | True r -> insert
                                    (union (inter (#1 bx) by)
                                       (inter (#3 bx) by))
                                    (#2 bx)
                      | False r -> union (inter (#1 bx) by)
                                     (inter (#3 bx) by))
2019-11-16 15:37:29.729066-05:00
Safe
2019-11-16 15:37:29.729075-05:00
verifying proves postcondition
2019-11-16 15:37:41.021700-05:00
postcondition proven
2019-11-16 15:37:41.021740-05:00
verifying: Leaf
2019-11-16 15:37:41.022321-05:00
Safe
2019-11-16 15:37:41.022329-05:00
verifying: fix size (b:bst) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#1 b)) (size (#3 b)))
2019-11-16 15:37:41.022889-05:00
Safe
2019-11-16 15:37:41.022897-05:00
verifying: fix lookup (b:bst) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#2 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#2 b) with
                                     | True c -> lookup (#1 b) x
                                     | False c -> lookup (#3 b) x))
2019-11-16 15:37:41.023493-05:00
Safe
2019-11-16 15:37:41.023500-05:00
verifying: fix insert (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#2 bp) with
                      | True c -> Node (insert (#1 bp) x, #2 bp, #3 bp)
                      | False c -> (match nat_eq x (#2 bp) with
                                      | True c -> b
                                      | False c -> Node (#1 bp, #2 bp,
                                                          insert (#3 bp) x)))
2019-11-16 15:37:41.117072-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-16 15:37:41.135929-05:00
testbed
2019-11-16 15:37:41.135946-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-16 15:37:41.200161-05:00
Answer list length: 3
2019-11-16 15:37:41.200184-05:00
Candidate invariant: fun (b1:bst) -> nat_eq (length (inter b1 b1)) (length b1)
2019-11-16 15:37:41.200686-05:00
Checking boundary for:Leaf
2019-11-16 15:37:41.201339-05:00
Safe
2019-11-16 15:37:41.201347-05:00
Checking boundary for:fix size (b:bst) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#1 b)) (size (#3 b)))
2019-11-16 15:37:41.250458-05:00
Safe
2019-11-16 15:37:41.250475-05:00
Checking boundary for:fix lookup (b:bst) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#2 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#2 b) with
                                     | True c -> lookup (#1 b) x
                                     | False c -> lookup (#3 b) x))
2019-11-16 15:37:41.251661-05:00
Safe
2019-11-16 15:37:41.251672-05:00
Checking boundary for:fix insert (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#2 bp) with
                      | True c -> Node (insert (#1 bp) x, #2 bp, #3 bp)
                      | False c -> (match nat_eq x (#2 bp) with
                                      | True c -> b
                                      | False c -> Node (#1 bp, #2 bp,
                                                          insert (#3 bp) x)))
2019-11-16 15:37:41.322135-05:00
Safe
2019-11-16 15:37:41.322159-05:00
Checking boundary for:fix delete (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#2 bp) with
                      | True c -> (match #1 bp with
                                     | Leaf bl -> #3 bp
                                     | Node bl -> (match #3 bp with
                                                     | Leaf br -> #1 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (#1 bp,
                                                                    m,
                                                                    delete
                                                                    (#3 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#3 bp))))
                      | False c -> (match nat_lt x (#2 bp) with
                                      | True c -> Node (delete (#1 bp) x,
                                                         #2 bp, #3 bp)
                                      | False c -> Node (#1 bp, #2 bp,
                                                          delete (#3 bp) x)))
2019-11-16 15:37:41.373884-05:00
Safe
2019-11-16 15:37:41.373909-05:00
Checking boundary for:fix union (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#1 bx) (union (#3 bx) (insert by (#2 bx)))
2019-11-16 15:37:41.375527-05:00
Safe
2019-11-16 15:37:41.375534-05:00
Checking boundary for:fix inter (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#2 bx) with
                      | True r -> insert
                                    (union (inter (#1 bx) by)
                                       (inter (#3 bx) by))
                                    (#2 bx)
                      | False r -> union (inter (#1 bx) by)
                                     (inter (#3 bx) by))
2019-11-16 15:37:41.422080-05:00
Safe
2019-11-16 15:37:41.422100-05:00
verifying proves postcondition
2019-11-16 15:37:53.122747-05:00
postcondition proven
2019-11-16 15:37:53.122789-05:00
verifying: Leaf
2019-11-16 15:37:53.123882-05:00
Safe
2019-11-16 15:37:53.123889-05:00
verifying: fix size (b:bst) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> add S 0 (add (size (#1 b)) (size (#3 b)))
2019-11-16 15:37:53.124655-05:00
Safe
2019-11-16 15:37:53.124660-05:00
verifying: fix lookup (b:bst) : nat -> bool =
  fun (x:nat) ->
    match b with
      | Leaf b -> False
      | Node b -> (match nat_eq x (#2 b) with
                     | True c -> True
                     | False c -> (match nat_lt x (#2 b) with
                                     | True c -> lookup (#1 b) x
                                     | False c -> lookup (#3 b) x))
2019-11-16 15:37:53.125238-05:00
Safe
2019-11-16 15:37:53.125244-05:00
verifying: fix insert (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Node (Leaf, x, Leaf)
      | Node bp -> (match nat_lt x (#2 bp) with
                      | True c -> Node (insert (#1 bp) x, #2 bp, #3 bp)
                      | False c -> (match nat_eq x (#2 bp) with
                                      | True c -> b
                                      | False c -> Node (#1 bp, #2 bp,
                                                          insert (#3 bp) x)))
2019-11-16 15:38:02.219957-05:00
Safe
2019-11-16 15:38:02.220003-05:00
verifying: fix delete (b:bst) : nat -> bst =
  fun (x:nat) ->
    match b with
      | Leaf bp -> Leaf
      | Node bp -> (match nat_eq x (#2 bp) with
                      | True c -> (match #1 bp with
                                     | Leaf bl -> #3 bp
                                     | Node bl -> (match #3 bp with
                                                     | Leaf br -> #1 bp
                                                     | Node br -> (fun (m:nat) ->
                                                                    Node 
                                                                    (#1 bp,
                                                                    m,
                                                                    delete
                                                                    (#3 bp) m))
                                                                    (
                                                                    min_val
                                                                    (#3 bp))))
                      | False c -> (match nat_lt x (#2 bp) with
                                      | True c -> Node (delete (#1 bp) x,
                                                         #2 bp, #3 bp)
                                      | False c -> Node (#1 bp, #2 bp,
                                                          delete (#3 bp) x)))
2019-11-16 15:38:08.812604-05:00
Safe
2019-11-16 15:38:08.812647-05:00
verifying: fix union (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> by
      | Node bx -> union (#1 bx) (union (#3 bx) (insert by (#2 bx)))
2019-11-16 15:38:08.857324-05:00
Safe
2019-11-16 15:38:08.857352-05:00
verifying: fix inter (bx:bst) : bst -> bst =
  fun (by:bst) ->
    match bx with
      | Leaf bx -> Leaf
      | Node bx -> (match lookup by (#2 bx) with
                      | True r -> insert
                                    (union (inter (#1 bx) by)
                                       (inter (#3 bx) by))
                                    (#2 bx)
                      | False r -> union (inter (#1 bx) by)
                                     (inter (#3 bx) by))
2019-11-16 15:38:08.893850-05:00
Safe
fun (b1:bst) -> nat_eq (length (inter b1 b1)) (length b1)
