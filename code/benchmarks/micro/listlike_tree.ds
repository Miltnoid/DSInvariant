type tree = mu tree .
  | Leaf
  | Node of (tree * nat * tree)

struct
  type t = tree

  let empty = Leaf ;;

  let size =
    fix (size : t -> nat) =
      fun (t : t) ->
        match t binding t with
        | Leaf -> O
        | Node ->
          add (S (size t.0)) (size t.2)
  ;;

  let height =
    fix (height : t -> nat) =
      fun (t : t) ->
        match t binding t with
        | Leaf -> O
        | Node ->
          (((fun (leftheight : nat) ->
            (fun (rightheight : nat) ->
              match nat_lt leftheight rightheight binding c with
              | True -> S rightheight
              | False -> S rightheight))
            (height t.0))
          (height t.2))
  ;;

  let insert =
    fix (insert : t -> nat -> t) =
      fun (t : t) ->
        fun (x : nat) ->
          match t binding t with
          | Leaf -> Node (Leaf,x,Leaf)
          | Node -> Node (t.0,t.1,insert t.2 x)
  ;;
end
:
sig
  type t

  val empty : t

  val size : t -> nat
  val height : t -> nat

  val insert : t -> nat -> t
end

maintains

forall (s : t) .
  (nat_eq (height s) (size s))