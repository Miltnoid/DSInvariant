2019-11-14 15:10:41.693694-05:00

2019-11-14 15:10:41.694225-05:00
DSInfer========================================================================
2019-11-14 15:10:41.694794-05:00
Answer list length: 2
2019-11-14 15:10:41.694818-05:00
Candidate invariant: fun (x:tree) -> False
2019-11-14 15:10:41.695360-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.696421-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
                                               Comes from
                                               ()
2019-11-14 15:10:41.696454-05:00
Answer list length: 1
2019-11-14 15:10:41.696469-05:00
Candidate invariant: fun (x:tree) -> True
2019-11-14 15:10:41.696668-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.696956-05:00
Safe
2019-11-14 15:10:41.696972-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.697308-05:00
Safe
2019-11-14 15:10:41.697324-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.697614-05:00
Safe
2019-11-14 15:10:41.697630-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.697990-05:00
Safe
2019-11-14 15:10:41.698008-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.698818-05:00
Safe
2019-11-14 15:10:41.698837-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:41.699217-05:00
Safe
2019-11-14 15:10:41.699231-05:00
verifying proves postcondition
2019-11-14 15:10:41.884455-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:41.884556-05:00
testbed
2019-11-14 15:10:41.884565-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests = [(Value.Ctor ("Leaf", (Value.Tuple [])))] }
2019-11-14 15:10:41.914856-05:00
Answer list length: 2
2019-11-14 15:10:41.914899-05:00
Candidate invariant: fun (t1:tree) -> nat_lte (size t1) 0
2019-11-14 15:10:41.915312-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.915627-05:00
Safe
2019-11-14 15:10:41.915638-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.916068-05:00
Safe
2019-11-14 15:10:41.916079-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.916353-05:00
Safe
2019-11-14 15:10:41.916364-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.916689-05:00
Safe
2019-11-14 15:10:41.916700-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.917175-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-14 15:10:41.917217-05:00
Answer list length: 1
2019-11-14 15:10:41.917227-05:00
Candidate invariant: fun (x:tree) -> True
2019-11-14 15:10:41.917420-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.917836-05:00
Safe
2019-11-14 15:10:41.917847-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.918173-05:00
Safe
2019-11-14 15:10:41.918184-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.918506-05:00
Safe
2019-11-14 15:10:41.918517-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.918848-05:00
Safe
2019-11-14 15:10:41.918860-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.920674-05:00
Safe
2019-11-14 15:10:41.920689-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:41.921064-05:00
Safe
2019-11-14 15:10:41.921076-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:41.921154-05:00
testbed
2019-11-14 15:10:41.921164-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:41.921891-05:00
Answer list length: 2
2019-11-14 15:10:41.921906-05:00
Candidate invariant: fun (t1:tree) -> nat_lte (true_maximum t1) 0
2019-11-14 15:10:41.922087-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.922381-05:00
Safe
2019-11-14 15:10:41.922392-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.922757-05:00
Safe
2019-11-14 15:10:41.922767-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.923071-05:00
Safe
2019-11-14 15:10:41.923082-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.923489-05:00
Safe
2019-11-14 15:10:41.923500-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.923963-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-14 15:10:41.924008-05:00
Answer list length: 1
2019-11-14 15:10:41.924017-05:00
Candidate invariant: fun (x:tree) -> True
2019-11-14 15:10:41.924309-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.924577-05:00
Safe
2019-11-14 15:10:41.924588-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.924874-05:00
Safe
2019-11-14 15:10:41.924885-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.925200-05:00
Safe
2019-11-14 15:10:41.925211-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.925557-05:00
Safe
2019-11-14 15:10:41.925568-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.928104-05:00
Safe
2019-11-14 15:10:41.928117-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:41.928529-05:00
Safe
2019-11-14 15:10:41.928541-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:41.928704-05:00
testbed
2019-11-14 15:10:41.928714-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:41.970036-05:00
Answer list length: 2
2019-11-14 15:10:41.970083-05:00
Candidate invariant: fun (t1:tree) -> nat_lte (size t1) S 0
2019-11-14 15:10:41.970365-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.970774-05:00
Safe
2019-11-14 15:10:41.970787-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.971112-05:00
Safe
2019-11-14 15:10:41.971128-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.971476-05:00
Safe
2019-11-14 15:10:41.971488-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.971838-05:00
Safe
2019-11-14 15:10:41.971854-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.973158-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:41.973250-05:00
Answer list length: 1
2019-11-14 15:10:41.973262-05:00
Candidate invariant: fun (x:tree) -> True
2019-11-14 15:10:41.973544-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.973840-05:00
Safe
2019-11-14 15:10:41.973852-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.974170-05:00
Safe
2019-11-14 15:10:41.974181-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.974483-05:00
Safe
2019-11-14 15:10:41.974494-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.974848-05:00
Safe
2019-11-14 15:10:41.974860-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.978176-05:00
Safe
2019-11-14 15:10:41.978191-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:41.978613-05:00
Safe
2019-11-14 15:10:41.978625-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:41.978941-05:00
testbed
2019-11-14 15:10:41.978952-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:41.981145-05:00
Answer list length: 2
2019-11-14 15:10:41.981167-05:00
Candidate invariant: fun (t1:tree) -> nat_lte (true_maximum (delete_max t1)) 0
2019-11-14 15:10:41.981361-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.981667-05:00
Safe
2019-11-14 15:10:41.981679-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.981988-05:00
Safe
2019-11-14 15:10:41.981999-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.982389-05:00
Safe
2019-11-14 15:10:41.982409-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.982786-05:00
Safe
2019-11-14 15:10:41.982797-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.986441-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:41.986522-05:00
Answer list length: 1
2019-11-14 15:10:41.986532-05:00
Candidate invariant: fun (x:tree) -> True
2019-11-14 15:10:41.986713-05:00
Checking boundary for:Leaf
2019-11-14 15:10:41.987021-05:00
Safe
2019-11-14 15:10:41.987032-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:41.987412-05:00
Safe
2019-11-14 15:10:41.987424-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:41.987760-05:00
Safe
2019-11-14 15:10:41.987772-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:41.988114-05:00
Safe
2019-11-14 15:10:41.988125-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:41.992429-05:00
Safe
2019-11-14 15:10:41.992444-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:41.992844-05:00
Safe
2019-11-14 15:10:41.992856-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:41.993182-05:00
testbed
2019-11-14 15:10:41.993192-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:42.064996-05:00
Answer list length: 2
2019-11-14 15:10:42.065038-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t2 with
                                       | Leaf N_fresh_var_1 -> True
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    False)
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:42.065316-05:00
Checking boundary for:Leaf
2019-11-14 15:10:42.065626-05:00
Safe
2019-11-14 15:10:42.065637-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:42.065951-05:00
Safe
2019-11-14 15:10:42.065962-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:42.066253-05:00
Safe
2019-11-14 15:10:42.066263-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:42.066584-05:00
Safe
2019-11-14 15:10:42.066595-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:42.070472-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:10:42.070569-05:00
Answer list length: 1
2019-11-14 15:10:42.070580-05:00
Candidate invariant: fun (x:tree) -> True
2019-11-14 15:10:42.070810-05:00
Checking boundary for:Leaf
2019-11-14 15:10:42.071121-05:00
Safe
2019-11-14 15:10:42.071132-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:42.071576-05:00
Safe
2019-11-14 15:10:42.071587-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:42.071867-05:00
Safe
2019-11-14 15:10:42.071882-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:42.072205-05:00
Safe
2019-11-14 15:10:42.072216-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:42.078763-05:00
Safe
2019-11-14 15:10:42.078780-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:42.079259-05:00
Safe
2019-11-14 15:10:42.079271-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:42.080046-05:00
testbed
2019-11-14 15:10:42.080057-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:42.128615-05:00
Answer list length: 2
2019-11-14 15:10:42.128660-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t2 with
                                       | Leaf N_fresh_var_1 -> True
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    contains
                                                                    t2 n1)
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:42.128952-05:00
Checking boundary for:Leaf
2019-11-14 15:10:42.129271-05:00
Safe
2019-11-14 15:10:42.129283-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:42.129617-05:00
Safe
2019-11-14 15:10:42.129628-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:42.129918-05:00
Safe
2019-11-14 15:10:42.129933-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:42.130270-05:00
Safe
2019-11-14 15:10:42.130280-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:42.134559-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:10:42.134681-05:00
Answer list length: 1
2019-11-14 15:10:42.134691-05:00
Candidate invariant: fun (x:tree) -> True
2019-11-14 15:10:42.134863-05:00
Checking boundary for:Leaf
2019-11-14 15:10:42.135145-05:00
Safe
2019-11-14 15:10:42.135156-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:42.135452-05:00
Safe
2019-11-14 15:10:42.135463-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:42.135745-05:00
Safe
2019-11-14 15:10:42.135756-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:42.136065-05:00
Safe
2019-11-14 15:10:42.136076-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:42.143259-05:00
Safe
2019-11-14 15:10:42.143279-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:42.143720-05:00
Safe
2019-11-14 15:10:42.143732-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:42.145776-05:00
testbed
2019-11-14 15:10:42.145789-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:42.170044-05:00
Answer list length: 2
2019-11-14 15:10:42.170080-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t2 with
                                       | Leaf N_fresh_var_1 -> True
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    nat_lte
                                                                    n2 n1)
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:42.170398-05:00
Checking boundary for:Leaf
2019-11-14 15:10:42.170729-05:00
Safe
2019-11-14 15:10:42.170741-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:42.171061-05:00
Safe
2019-11-14 15:10:42.171072-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:42.171420-05:00
Safe
2019-11-14 15:10:42.171431-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:42.171797-05:00
Safe
2019-11-14 15:10:42.171808-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:42.183867-05:00
Safe
2019-11-14 15:10:42.183891-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:42.184531-05:00
Safe
2019-11-14 15:10:42.184544-05:00
verifying proves postcondition
2019-11-14 15:10:42.374257-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:10:42.381087-05:00
testbed
2019-11-14 15:10:42.381123-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:42.442254-05:00
Answer list length: 3
2019-11-14 15:10:42.442295-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     nat_eq n1 (true_maximum t1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:42.442536-05:00
Checking boundary for:Leaf
2019-11-14 15:10:42.442874-05:00
Safe
2019-11-14 15:10:42.442886-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:42.443231-05:00
Safe
2019-11-14 15:10:42.443242-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:42.443540-05:00
Safe
2019-11-14 15:10:42.443552-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:42.443877-05:00
Safe
2019-11-14 15:10:42.443888-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:42.472838-05:00
Safe
2019-11-14 15:10:42.472882-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:42.473959-05:00
Safe
2019-11-14 15:10:42.473980-05:00
verifying proves postcondition
2019-11-14 15:10:47.704966-05:00
postcondition proven
2019-11-14 15:10:47.705013-05:00
verifying: Leaf
2019-11-14 15:10:47.705607-05:00
Safe
2019-11-14 15:10:47.705619-05:00
verifying: fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:47.705967-05:00
Safe
2019-11-14 15:10:47.705978-05:00
verifying: fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:47.706380-05:00
Safe
2019-11-14 15:10:47.706391-05:00
verifying: fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:47.706716-05:00
Safe
2019-11-14 15:10:47.706727-05:00
verifying: fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:54.956938-05:00
Safe
2019-11-14 15:10:54.956981-05:00
verifying: fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:55.024200-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Node\",\n                  (Value.Tuple\n                     [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                       (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                          ));\n                       (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                  ));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:10:55.036598-05:00
testbed
2019-11-14 15:10:55.036618-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Node",
                     (Value.Tuple
                        [(Value.Ctor ("Leaf", (Value.Tuple [])));
                          (Value.Ctor ("S",
                             (Value.Ctor ("O", (Value.Tuple [])))));
                          (Value.Ctor ("Leaf", (Value.Tuple [])))])
                     ));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:55.119921-05:00
Answer list length: 4
2019-11-14 15:10:55.119971-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match n1 with
                                       | O N_fresh_var_1 -> nat_eq n1
                                                              (true_maximum
                                                                 t1)
                                       | S N_fresh_var_1 -> (fun (n2:unit) ->
                                                               f1 t3)
                                                              N_fresh_var_1)
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:55.120237-05:00
Checking boundary for:Leaf
2019-11-14 15:10:55.120602-05:00
Safe
2019-11-14 15:10:55.120614-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:55.120972-05:00
Safe
2019-11-14 15:10:55.120983-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:55.121372-05:00
Safe
2019-11-14 15:10:55.121384-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:55.121726-05:00
Safe
2019-11-14 15:10:55.121737-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:55.143283-05:00
Safe
2019-11-14 15:10:55.143321-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:55.144108-05:00
Safe
2019-11-14 15:10:55.144121-05:00
verifying proves postcondition
2019-11-14 15:10:55.395823-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\",\n                  (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:55.418281-05:00
testbed
2019-11-14 15:10:55.418322-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:56.548090-05:00
Answer list length: 5
2019-11-14 15:10:56.548138-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match n1 with
                                       | O N_fresh_var_1 -> nat_eq n1
                                                              (true_maximum
                                                                 t1)
                                       | S N_fresh_var_1 -> (fun (n2:unit) ->
                                                               nat_eq
                                                                 S (size
                                                                    (delete_max
                                                                    t3))
                                                                 (true_maximum
                                                                    t1))
                                                              N_fresh_var_1)
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:56.548407-05:00
Checking boundary for:Leaf
2019-11-14 15:10:56.548786-05:00
Safe
2019-11-14 15:10:56.548798-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:56.549131-05:00
Safe
2019-11-14 15:10:56.549143-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:56.549451-05:00
Safe
2019-11-14 15:10:56.549462-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:56.549790-05:00
Safe
2019-11-14 15:10:56.549801-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:56.550640-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\",\n           (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Leaf\", (Value.Tuple [])))")
2019-11-14 15:10:56.552120-05:00
Answer list length: 4
2019-11-14 15:10:56.552133-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match n1 with
                                       | O N_fresh_var_1 -> nat_eq n1
                                                              (true_maximum
                                                                 t1)
                                       | S N_fresh_var_1 -> (fun (n2:unit) ->
                                                               f1 t3)
                                                              N_fresh_var_1)
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:56.552350-05:00
Checking boundary for:Leaf
2019-11-14 15:10:56.552669-05:00
Safe
2019-11-14 15:10:56.552681-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:56.552991-05:00
Safe
2019-11-14 15:10:56.553002-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:56.553300-05:00
Safe
2019-11-14 15:10:56.553311-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:56.553630-05:00
Safe
2019-11-14 15:10:56.553641-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:56.576311-05:00
Safe
2019-11-14 15:10:56.576350-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:56.577143-05:00
Safe
2019-11-14 15:10:56.577156-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\",\n                  (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:56.602247-05:00
testbed
2019-11-14 15:10:56.602285-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S",
                     (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))
                     ));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:56.663947-05:00
Answer list length: 5
2019-11-14 15:10:56.663995-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> nat_eq n1
                                                                 (true_maximum
                                                                    t1)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    contains
                                                                    (insert
                                                                    t2 n1) n2)
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:56.664338-05:00
Checking boundary for:Leaf
2019-11-14 15:10:56.664716-05:00
Safe
2019-11-14 15:10:56.664729-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:56.665095-05:00
Safe
2019-11-14 15:10:56.665106-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:56.665420-05:00
Safe
2019-11-14 15:10:56.665432-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:56.665771-05:00
Safe
2019-11-14 15:10:56.665782-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:56.670859-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:56.672780-05:00
Answer list length: 4
2019-11-14 15:10:56.672814-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match n1 with
                                       | O N_fresh_var_1 -> nat_eq n1
                                                              (true_maximum
                                                                 t1)
                                       | S N_fresh_var_1 -> (fun (n2:unit) ->
                                                               f1 t3)
                                                              N_fresh_var_1)
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:56.673109-05:00
Checking boundary for:Leaf
2019-11-14 15:10:56.673574-05:00
Safe
2019-11-14 15:10:56.673588-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:56.673964-05:00
Safe
2019-11-14 15:10:56.673977-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:56.674327-05:00
Safe
2019-11-14 15:10:56.674347-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:56.674755-05:00
Safe
2019-11-14 15:10:56.674778-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:56.708339-05:00
Safe
2019-11-14 15:10:56.708384-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:56.709463-05:00
Safe
2019-11-14 15:10:56.709477-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\",\n                  (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:10:56.747168-05:00
testbed
2019-11-14 15:10:56.747202-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S",
                     (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))
                     ));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Leaf", (Value.Tuple [])));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:57.042863-05:00
Answer list length: 5
2019-11-14 15:10:57.042911-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> nat_eq n1
                                                                 (true_maximum
                                                                    t1)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (nat_lte
                                                                    n2 n1)
                                                                    (f1 t3))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:57.043202-05:00
Checking boundary for:Leaf
2019-11-14 15:10:57.043574-05:00
Safe
2019-11-14 15:10:57.043586-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:57.043911-05:00
Safe
2019-11-14 15:10:57.043922-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:57.044247-05:00
Safe
2019-11-14 15:10:57.044258-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:57.044580-05:00
Safe
2019-11-14 15:10:57.044591-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:57.079723-05:00
Safe
2019-11-14 15:10:57.079765-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:57.080968-05:00
Safe
2019-11-14 15:10:57.080983-05:00
verifying proves postcondition
2019-11-14 15:10:57.401767-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:10:57.484175-05:00
Answer list length: 6
2019-11-14 15:10:57.484227-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match n1 with
                                       | O N_fresh_var_1 -> nat_eq n1
                                                              (true_maximum
                                                                 t1)
                                       | S N_fresh_var_1 -> (fun (n2:unit) ->
                                                               nat_eq
                                                                 (size
                                                                    (
                                                                    delete_max
                                                                    t3))
                                                                 (true_maximum
                                                                    t2))
                                                              N_fresh_var_1)
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:57.484511-05:00
Checking boundary for:Leaf
2019-11-14 15:10:57.485007-05:00
Safe
2019-11-14 15:10:57.485020-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:57.485349-05:00
Safe
2019-11-14 15:10:57.485360-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:57.485898-05:00
Safe
2019-11-14 15:10:57.485914-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:57.486261-05:00
Safe
2019-11-14 15:10:57.486272-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:57.509636-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:10:57.514015-05:00
Answer list length: 5
2019-11-14 15:10:57.514036-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> nat_eq n1
                                                                 (true_maximum
                                                                    t1)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (nat_lte
                                                                    n2 n1)
                                                                    (f1 t3))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:57.514315-05:00
Checking boundary for:Leaf
2019-11-14 15:10:57.514656-05:00
Safe
2019-11-14 15:10:57.514668-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:57.515000-05:00
Safe
2019-11-14 15:10:57.515010-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:57.515377-05:00
Safe
2019-11-14 15:10:57.515387-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:57.515717-05:00
Safe
2019-11-14 15:10:57.515728-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:57.568515-05:00
Safe
2019-11-14 15:10:57.568558-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:57.569673-05:00
Safe
2019-11-14 15:10:57.569686-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:10:57.631795-05:00
testbed
2019-11-14 15:10:57.631833-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:10:58.084332-05:00
Answer list length: 6
2019-11-14 15:10:58.084383-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     and (f1 t3)
                                       (nat_eq n1 (true_maximum t1)))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:10:58.084642-05:00
Checking boundary for:Leaf
2019-11-14 15:10:58.084980-05:00
Safe
2019-11-14 15:10:58.084995-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:10:58.085320-05:00
Safe
2019-11-14 15:10:58.085331-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:10:58.085732-05:00
Safe
2019-11-14 15:10:58.085743-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:10:58.086107-05:00
Safe
2019-11-14 15:10:58.086122-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:10:58.166499-05:00
Safe
2019-11-14 15:10:58.166545-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:10:58.167693-05:00
Safe
2019-11-14 15:10:58.167708-05:00
verifying proves postcondition
2019-11-14 15:11:03.821013-05:00
postcondition proven
2019-11-14 15:11:03.821065-05:00
verifying: Leaf
2019-11-14 15:11:03.821687-05:00
Safe
2019-11-14 15:11:03.821701-05:00
verifying: fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:03.822066-05:00
Safe
2019-11-14 15:11:03.822079-05:00
verifying: fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:03.822484-05:00
Safe
2019-11-14 15:11:03.822498-05:00
verifying: fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:03.822864-05:00
Safe
2019-11-14 15:11:03.822876-05:00
verifying: fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:12.768819-05:00
Safe
2019-11-14 15:11:12.768869-05:00
verifying: fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:12.856116-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Node\",\n                 (Value.Tuple\n                    [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                      (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                         ));\n                      (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                 ));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:11:12.939015-05:00
testbed
2019-11-14 15:11:12.939064-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Node",
                    (Value.Tuple
                       [(Value.Ctor ("Leaf", (Value.Tuple [])));
                         (Value.Ctor ("S",
                            (Value.Ctor ("O", (Value.Tuple [])))));
                         (Value.Ctor ("Leaf", (Value.Tuple [])))])
                    ));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:11:13.915554-05:00
Answer list length: 7
2019-11-14 15:11:13.915607-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match n1 with
                                       | O N_fresh_var_1 -> nat_eq n1
                                                              (true_maximum
                                                                 t1)
                                       | S N_fresh_var_1 -> (fun (n2:unit) ->
                                                               nat_eq
                                                                 (size t2)
                                                                 (size
                                                                    (
                                                                    delete_max
                                                                    (delete_max
                                                                    t1))))
                                                              N_fresh_var_1)
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:13.915869-05:00
Checking boundary for:Leaf
2019-11-14 15:11:13.916249-05:00
Safe
2019-11-14 15:11:13.916261-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:13.916744-05:00
Safe
2019-11-14 15:11:13.916755-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:13.917052-05:00
Safe
2019-11-14 15:11:13.917063-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:13.917412-05:00
Safe
2019-11-14 15:11:13.917423-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:13.955121-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"O\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ))\n                ])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:13.960974-05:00
Answer list length: 6
2019-11-14 15:11:13.961019-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     and (f1 t3)
                                       (nat_eq n1 (true_maximum t1)))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:13.961413-05:00
Checking boundary for:Leaf
2019-11-14 15:11:13.961946-05:00
Safe
2019-11-14 15:11:13.961966-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:13.962572-05:00
Safe
2019-11-14 15:11:13.962587-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:13.962953-05:00
Safe
2019-11-14 15:11:13.962966-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:13.963474-05:00
Safe
2019-11-14 15:11:13.963488-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:14.058262-05:00
Safe
2019-11-14 15:11:14.058308-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:14.060291-05:00
Safe
2019-11-14 15:11:14.060310-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Node\",\n                 (Value.Tuple\n                    [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                      (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                         ));\n                      (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                 ));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:11:14.195528-05:00
Answer list length: 7
2019-11-14 15:11:14.195579-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t2 with
                                       | Leaf N_fresh_var_1 -> and
                                                                 (nat_lte
                                                                    (
                                                                    true_maximum
                                                                    t3) n1)
                                                                 (f1 t3)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    contains
                                                                    (insert
                                                                    t3 n1) n2)
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:14.195880-05:00
Checking boundary for:Leaf
2019-11-14 15:11:14.196230-05:00
Safe
2019-11-14 15:11:14.196242-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:14.196557-05:00
Safe
2019-11-14 15:11:14.196569-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:14.196876-05:00
Safe
2019-11-14 15:11:14.196887-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:14.197232-05:00
Safe
2019-11-14 15:11:14.197243-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:14.225087-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\",\n           (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:14.229744-05:00
Answer list length: 6
2019-11-14 15:11:14.229762-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     and (f1 t3)
                                       (nat_eq n1 (true_maximum t1)))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:14.230016-05:00
Checking boundary for:Leaf
2019-11-14 15:11:14.230357-05:00
Safe
2019-11-14 15:11:14.230380-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:14.230728-05:00
Safe
2019-11-14 15:11:14.230738-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:14.231017-05:00
Safe
2019-11-14 15:11:14.231027-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:14.231356-05:00
Safe
2019-11-14 15:11:14.231367-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:14.316045-05:00
Safe
2019-11-14 15:11:14.316091-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:14.317423-05:00
Safe
2019-11-14 15:11:14.317444-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Node\",\n                 (Value.Tuple\n                    [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                      (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                         ));\n                      (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                 ));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:11:14.402519-05:00
testbed
2019-11-14 15:11:14.402566-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Node",
                    (Value.Tuple
                       [(Value.Ctor ("Leaf", (Value.Tuple [])));
                         (Value.Ctor ("S",
                            (Value.Ctor ("O", (Value.Tuple [])))));
                         (Value.Ctor ("Leaf", (Value.Tuple [])))])
                    ));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S",
              (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ))
                    ])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:11:15.807761-05:00
Answer list length: 7
2019-11-14 15:11:15.807814-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> nat_lte
                                                                 (size t2) 0
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (f1 t3)
                                                                    (nat_eq
                                                                    n1
                                                                    (true_maximum
                                                                    t1)))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:15.810031-05:00
Checking boundary for:Leaf
2019-11-14 15:11:15.810516-05:00
Safe
2019-11-14 15:11:15.810531-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:15.810946-05:00
Safe
2019-11-14 15:11:15.810960-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:15.811426-05:00
Safe
2019-11-14 15:11:15.811450-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:15.811884-05:00
Safe
2019-11-14 15:11:15.811898-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:15.899695-05:00
Safe
2019-11-14 15:11:15.899737-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:15.900715-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:15.905997-05:00
Answer list length: 6
2019-11-14 15:11:15.906020-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     and (f1 t3)
                                       (nat_eq n1 (true_maximum t1)))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:15.906259-05:00
Checking boundary for:Leaf
2019-11-14 15:11:15.906598-05:00
Safe
2019-11-14 15:11:15.906610-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:15.906975-05:00
Safe
2019-11-14 15:11:15.906986-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:15.907284-05:00
Safe
2019-11-14 15:11:15.907295-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:15.907616-05:00
Safe
2019-11-14 15:11:15.907627-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:16.012235-05:00
Safe
2019-11-14 15:11:16.012285-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:16.013855-05:00
Safe
2019-11-14 15:11:16.013872-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Node\",\n                 (Value.Tuple\n                    [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                      (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                         ));\n                      (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                 ));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
2019-11-14 15:11:16.177640-05:00
Answer list length: 7
2019-11-14 15:11:16.177690-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t2 with
                                       | Leaf N_fresh_var_1 -> and
                                                                 (nat_lte
                                                                    (
                                                                    true_maximum
                                                                    t3) n1)
                                                                 (f1 t3)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (nat_lte
                                                                    n2 n1)
                                                                    (f1 t2))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:16.178005-05:00
Checking boundary for:Leaf
2019-11-14 15:11:16.178352-05:00
Safe
2019-11-14 15:11:16.178364-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:16.178731-05:00
Safe
2019-11-14 15:11:16.178742-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:16.179119-05:00
Safe
2019-11-14 15:11:16.179131-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:16.179526-05:00
Safe
2019-11-14 15:11:16.179539-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:16.247201-05:00
Safe
2019-11-14 15:11:16.247245-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:16.248622-05:00
Safe
2019-11-14 15:11:16.248637-05:00
verifying proves postcondition
2019-11-14 15:11:16.555081-05:00
postcondition unproven, counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:16.712403-05:00
testbed
2019-11-14 15:11:16.712451-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Node",
                     (Value.Tuple
                        [(Value.Ctor ("Leaf", (Value.Tuple [])));
                          (Value.Ctor ("S",
                             (Value.Ctor ("O", (Value.Tuple [])))));
                          (Value.Ctor ("Leaf", (Value.Tuple [])))])
                     ));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ))
                    ])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:11:18.312721-05:00
Answer list length: 8
2019-11-14 15:11:18.312773-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> nat_lte
                                                                 (true_maximum
                                                                    t2)
                                                                 0
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (f1 t3)
                                                                    (nat_eq
                                                                    n1
                                                                    (true_maximum
                                                                    t1)))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:18.313051-05:00
Checking boundary for:Leaf
2019-11-14 15:11:18.313419-05:00
Safe
2019-11-14 15:11:18.313431-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:18.313777-05:00
Safe
2019-11-14 15:11:18.313788-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:18.314088-05:00
Safe
2019-11-14 15:11:18.314099-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:18.314430-05:00
Safe
2019-11-14 15:11:18.314441-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:18.428072-05:00
Safe
2019-11-14 15:11:18.428111-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:18.429556-05:00
Safe
2019-11-14 15:11:18.429570-05:00
verifying proves postcondition
2019-11-14 15:11:24.252265-05:00
postcondition proven
2019-11-14 15:11:24.252315-05:00
verifying: Leaf
2019-11-14 15:11:24.252713-05:00
Safe
2019-11-14 15:11:24.252726-05:00
verifying: fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:24.253079-05:00
Safe
2019-11-14 15:11:24.253090-05:00
verifying: fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:24.253382-05:00
Safe
2019-11-14 15:11:24.253393-05:00
verifying: fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:24.253729-05:00
Safe
2019-11-14 15:11:24.253740-05:00
verifying: fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:33.170824-05:00
Safe
2019-11-14 15:11:33.170875-05:00
verifying: fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:33.301815-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:33.482176-05:00
testbed
2019-11-14 15:11:33.482219-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Node",
                     (Value.Tuple
                        [(Value.Ctor ("Leaf", (Value.Tuple [])));
                          (Value.Ctor ("S",
                             (Value.Ctor ("O", (Value.Tuple [])))));
                          (Value.Ctor ("Leaf", (Value.Tuple [])))])
                     ));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("O", (Value.Tuple [])));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ))
                    ])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:11:37.826901-05:00
Answer list length: 9
2019-11-14 15:11:37.826955-05:00
Candidate invariant: fun (t1:tree) ->
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match delete_max (delete_max t1) with
                                       | Leaf N_fresh_var_1 -> nat_eq n1
                                                                 (true_maximum
                                                                    t1)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    nat_lte
                                                                    (add n2
                                                                    (true_maximum
                                                                    t1)) n1)
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:37.827230-05:00
Checking boundary for:Leaf
2019-11-14 15:11:37.827662-05:00
Safe
2019-11-14 15:11:37.827674-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:37.827972-05:00
Safe
2019-11-14 15:11:37.827983-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:37.828284-05:00
Safe
2019-11-14 15:11:37.828295-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:37.828617-05:00
Safe
2019-11-14 15:11:37.828628-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:37.898721-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:37.913386-05:00
Answer list length: 8
2019-11-14 15:11:37.913426-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> nat_lte
                                                                 (true_maximum
                                                                    t2)
                                                                 0
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (f1 t3)
                                                                    (nat_eq
                                                                    n1
                                                                    (true_maximum
                                                                    t1)))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:37.913717-05:00
Checking boundary for:Leaf
2019-11-14 15:11:37.914159-05:00
Safe
2019-11-14 15:11:37.914171-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:37.914483-05:00
Safe
2019-11-14 15:11:37.914495-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:37.914923-05:00
Safe
2019-11-14 15:11:37.914935-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:37.915283-05:00
Safe
2019-11-14 15:11:37.915295-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:38.091413-05:00
Safe
2019-11-14 15:11:38.091455-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:38.093334-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:38.113186-05:00
Answer list length: 7
2019-11-14 15:11:38.113228-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t2 with
                                       | Leaf N_fresh_var_1 -> and
                                                                 (nat_lte
                                                                    (
                                                                    true_maximum
                                                                    t3) n1)
                                                                 (f1 t3)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (nat_lte
                                                                    n2 n1)
                                                                    (f1 t2))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:38.113512-05:00
Checking boundary for:Leaf
2019-11-14 15:11:38.113853-05:00
Safe
2019-11-14 15:11:38.113865-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:38.114201-05:00
Safe
2019-11-14 15:11:38.114212-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:38.114630-05:00
Safe
2019-11-14 15:11:38.114642-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:38.114998-05:00
Safe
2019-11-14 15:11:38.115009-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:38.205465-05:00
Safe
2019-11-14 15:11:38.205508-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:38.207737-05:00
Safe
2019-11-14 15:11:38.207755-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:38.486146-05:00
Answer list length: 8
2019-11-14 15:11:38.486199-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t2 with
                                       | Leaf N_fresh_var_1 -> and
                                                                 (nat_lte
                                                                    (
                                                                    true_maximum
                                                                    t3) n1)
                                                                 (f1 t3)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (nat_eq
                                                                    n1
                                                                    (true_maximum
                                                                    t1))
                                                                    (f1 t2))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:11:38.486495-05:00
Checking boundary for:Leaf
2019-11-14 15:11:38.486905-05:00
Safe
2019-11-14 15:11:38.486918-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:38.487265-05:00
Safe
2019-11-14 15:11:38.487276-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:38.487598-05:00
Safe
2019-11-14 15:11:38.487610-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:38.487968-05:00
Safe
2019-11-14 15:11:38.487980-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:38.606097-05:00
Safe
2019-11-14 15:11:38.606140-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:38.608568-05:00
Safe
2019-11-14 15:11:38.608583-05:00
verifying proves postcondition
2019-11-14 15:11:44.888906-05:00
postcondition proven
2019-11-14 15:11:44.888955-05:00
verifying: Leaf
2019-11-14 15:11:44.889363-05:00
Safe
2019-11-14 15:11:44.889375-05:00
verifying: fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:11:44.889743-05:00
Safe
2019-11-14 15:11:44.889757-05:00
verifying: fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:11:44.890048-05:00
Safe
2019-11-14 15:11:44.890059-05:00
verifying: fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:11:44.890377-05:00
Safe
2019-11-14 15:11:44.890388-05:00
verifying: fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:11:55.969385-05:00
Safe
2019-11-14 15:11:55.969435-05:00
verifying: fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:11:58.088524-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Node\",\n                 (Value.Tuple\n                    [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                      (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                         ));\n                      (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                 ));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Node\",\n                  (Value.Tuple\n                     [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                       (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                          ));\n                       (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                  ));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:11:58.346871-05:00
testbed
2019-11-14 15:11:58.346920-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Node",
                     (Value.Tuple
                        [(Value.Ctor ("Leaf", (Value.Tuple [])));
                          (Value.Ctor ("S",
                             (Value.Ctor ("O", (Value.Tuple [])))));
                          (Value.Ctor ("Leaf", (Value.Tuple [])))])
                     ));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Node",
                     (Value.Tuple
                        [(Value.Ctor ("Leaf", (Value.Tuple [])));
                          (Value.Ctor ("S",
                             (Value.Ctor ("O", (Value.Tuple [])))));
                          (Value.Ctor ("Leaf", (Value.Tuple [])))])
                     ));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ))
                    ])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:12:00.501315-05:00
Answer list length: 9
2019-11-14 15:12:00.501367-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> and
                                                                 (nat_eq n1
                                                                    (
                                                                    true_maximum
                                                                    t1))
                                                                 (f1 t2)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (f1 t3)
                                                                    (nat_eq
                                                                    n1
                                                                    (true_maximum
                                                                    t1)))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:12:00.501647-05:00
Checking boundary for:Leaf
2019-11-14 15:12:00.502399-05:00
Safe
2019-11-14 15:12:00.502419-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:12:00.502747-05:00
Safe
2019-11-14 15:12:00.502758-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:12:00.503074-05:00
Safe
2019-11-14 15:12:00.503085-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:12:00.503481-05:00
Safe
2019-11-14 15:12:00.503496-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:12:00.687972-05:00
Safe
2019-11-14 15:12:00.688016-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:12:00.691078-05:00
Safe
2019-11-14 15:12:00.691103-05:00
verifying proves postcondition
2019-11-14 15:12:07.488367-05:00
postcondition proven
2019-11-14 15:12:07.488415-05:00
verifying: Leaf
2019-11-14 15:12:07.488930-05:00
Safe
2019-11-14 15:12:07.488941-05:00
verifying: fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:12:07.489271-05:00
Safe
2019-11-14 15:12:07.489282-05:00
verifying: fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:12:07.489595-05:00
Safe
2019-11-14 15:12:07.489605-05:00
verifying: fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:12:07.489918-05:00
Safe
2019-11-14 15:12:07.489929-05:00
verifying: fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:12:21.294798-05:00
Safe
2019-11-14 15:12:21.294844-05:00
verifying: fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:12:23.690603-05:00
Not a LR, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"O\", (Value.Tuple [])));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Node\",\n                 (Value.Tuple\n                    [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                      (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                         ));\n                      (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                 ));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:12:23.967130-05:00
testbed
2019-11-14 15:12:23.967171-05:00
{ TestBed.neg_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Node",
                    (Value.Tuple
                       [(Value.Ctor ("Leaf", (Value.Tuple [])));
                         (Value.Ctor ("S",
                            (Value.Ctor ("O", (Value.Tuple [])))));
                         (Value.Ctor ("Leaf", (Value.Tuple [])))])
                    ));
                  (Value.Ctor ("O", (Value.Tuple [])));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ))
           ])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Node",
                     (Value.Tuple
                        [(Value.Ctor ("Leaf", (Value.Tuple [])));
                          (Value.Ctor ("S",
                             (Value.Ctor ("O", (Value.Tuple [])))));
                          (Value.Ctor ("Leaf", (Value.Tuple [])))])
                     ));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S",
                      (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))
                         ))
                      ));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Node",
                      (Value.Tuple
                         [(Value.Ctor ("Leaf", (Value.Tuple [])));
                           (Value.Ctor ("S",
                              (Value.Ctor ("O", (Value.Tuple [])))));
                           (Value.Ctor ("Leaf", (Value.Tuple [])))])
                      ));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ))
    ];
  pos_tests =
  [(Value.Ctor ("Node",
      (Value.Tuple
         [(Value.Ctor ("Node",
             (Value.Tuple
                [(Value.Ctor ("Leaf", (Value.Tuple [])));
                  (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                  (Value.Ctor ("Leaf", (Value.Tuple [])))])
             ));
           (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
           (Value.Ctor ("Leaf", (Value.Tuple [])))])
      ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Node",
                       (Value.Tuple
                          [(Value.Ctor ("Leaf", (Value.Tuple [])));
                            (Value.Ctor ("O", (Value.Tuple [])));
                            (Value.Ctor ("Leaf", (Value.Tuple [])))])
                       ))
                    ])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S",
               (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Node",
              (Value.Tuple
                 [(Value.Ctor ("Leaf", (Value.Tuple [])));
                   (Value.Ctor ("O", (Value.Tuple [])));
                   (Value.Ctor ("Leaf", (Value.Tuple [])))])
              ));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Node",
               (Value.Tuple
                  [(Value.Ctor ("Leaf", (Value.Tuple [])));
                    (Value.Ctor ("O", (Value.Tuple [])));
                    (Value.Ctor ("Leaf", (Value.Tuple [])))])
               ))
            ])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("S", (Value.Ctor ("O", (Value.Tuple [])))));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Node",
       (Value.Tuple
          [(Value.Ctor ("Leaf", (Value.Tuple [])));
            (Value.Ctor ("O", (Value.Tuple [])));
            (Value.Ctor ("Leaf", (Value.Tuple [])))])
       ));
    (Value.Ctor ("Leaf", (Value.Tuple [])))]
  }
2019-11-14 15:12:43.023086-05:00
Answer list length: 10
2019-11-14 15:12:43.023149-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match delete_max t2 with
                                       | Leaf N_fresh_var_1 -> and (f1 t3)
                                                                 (nat_eq n1
                                                                    (
                                                                    true_maximum
                                                                    t1))
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    False)
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:12:43.023536-05:00
Checking boundary for:Leaf
2019-11-14 15:12:43.024266-05:00
Safe
2019-11-14 15:12:43.024281-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:12:43.024582-05:00
Safe
2019-11-14 15:12:43.024593-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:12:43.024897-05:00
Safe
2019-11-14 15:12:43.024908-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:12:43.025293-05:00
Safe
2019-11-14 15:12:43.025304-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:12:43.152290-05:00
Boundary Not Satisfied, counterexample:
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Node\",\n                  (Value.Tuple\n                     [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                       (Value.Ctor (\"O\", (Value.Tuple [])));\n                       (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                  ))\n               ])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"O\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ))\n                ])\n           ))\n        ])\n   ))")
                                               Comes from
                                               ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Node\",\n                   (Value.Tuple\n                      [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                        (Value.Ctor (\"O\", (Value.Tuple [])));\n                        (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                   ))\n                ])\n           ))\n        ])\n   ))")
2019-11-14 15:12:43.175648-05:00
Answer list length: 9
2019-11-14 15:12:43.175691-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match t3 with
                                       | Leaf N_fresh_var_1 -> and
                                                                 (nat_eq n1
                                                                    (
                                                                    true_maximum
                                                                    t1))
                                                                 (f1 t2)
                                       | Node N_fresh_var_1 -> (fun (t4:unit) ->
                                                                  (fun (n2:unit) ->
                                                                    (fun (t5:unit) ->
                                                                    and
                                                                    (f1 t3)
                                                                    (nat_eq
                                                                    n1
                                                                    (true_maximum
                                                                    t1)))
                                                                    (#3
                                                                    N_fresh_var_1))
                                                                    (
                                                                    #2
                                                                    N_fresh_var_1))
                                                                 (#1
                                                                    N_fresh_var_1))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:12:43.175977-05:00
Checking boundary for:Leaf
2019-11-14 15:12:43.176377-05:00
Safe
2019-11-14 15:12:43.176390-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:12:43.176726-05:00
Safe
2019-11-14 15:12:43.176738-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:12:43.177123-05:00
Safe
2019-11-14 15:12:43.177134-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:12:43.177458-05:00
Safe
2019-11-14 15:12:43.177469-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:12:43.456425-05:00
Safe
2019-11-14 15:12:43.456473-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:12:43.459461-05:00
Safe
2019-11-14 15:12:43.459476-05:00
Prior counterexample: ("(Value.Ctor (\"Node\",\n   (Value.Tuple\n      [(Value.Ctor (\"Node\",\n          (Value.Tuple\n             [(Value.Ctor (\"Node\",\n                 (Value.Tuple\n                    [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                      (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))\n                         ));\n                      (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n                 ));\n               (Value.Ctor (\"O\", (Value.Tuple [])));\n               (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n          ));\n        (Value.Ctor (\"S\", (Value.Ctor (\"O\", (Value.Tuple [])))));\n        (Value.Ctor (\"Node\",\n           (Value.Tuple\n              [(Value.Ctor (\"Leaf\", (Value.Tuple [])));\n                (Value.Ctor (\"O\", (Value.Tuple [])));\n                (Value.Ctor (\"Leaf\", (Value.Tuple [])))])\n           ))\n        ])\n   ))")
2019-11-14 15:12:50.375393-05:00
Answer list length: 10
2019-11-14 15:12:50.375445-05:00
Candidate invariant: fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match f1 t2 with
                                       | False N_fresh_var_1 -> False
                                       | True N_fresh_var_1 -> and (f1 t3)
                                                                 (nat_eq n1
                                                                    (
                                                                    true_maximum
                                                                    t1)))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)
2019-11-14 15:12:50.375892-05:00
Checking boundary for:Leaf
2019-11-14 15:12:50.376242-05:00
Safe
2019-11-14 15:12:50.376254-05:00
Checking boundary for:fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:12:50.376565-05:00
Safe
2019-11-14 15:12:50.376577-05:00
Checking boundary for:fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:12:50.376892-05:00
Safe
2019-11-14 15:12:50.376904-05:00
Checking boundary for:fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:12:50.377248-05:00
Safe
2019-11-14 15:12:50.377259-05:00
Checking boundary for:fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:12:50.499831-05:00
Safe
2019-11-14 15:12:50.499878-05:00
Checking boundary for:fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:12:50.502160-05:00
Safe
2019-11-14 15:12:50.502197-05:00
verifying proves postcondition
2019-11-14 15:12:56.589269-05:00
postcondition proven
2019-11-14 15:12:56.589333-05:00
verifying: Leaf
2019-11-14 15:12:56.589816-05:00
Safe
2019-11-14 15:12:56.589829-05:00
verifying: fix size (b:tree) : nat =
  match b with
    | Leaf b -> 0
    | Node b -> S (add (size (#1 b)) (size (#3 b)))
2019-11-14 15:12:56.590172-05:00
Safe
2019-11-14 15:12:56.590183-05:00
verifying: fun (b:tree) -> match b with
                  | Leaf b -> None
                  | Node b -> Some (#2 b)
2019-11-14 15:12:56.590503-05:00
Safe
2019-11-14 15:12:56.590514-05:00
verifying: fix contains (x:tree) : nat -> bool =
  fun (n:nat) ->
    match x with
      | Leaf vs -> False
      | Node vs -> (match nat_eq (#2 vs) n with
                      | True c -> True
                      | False c -> or (contains (#1 vs) n)
                                     (contains (#3 vs) n))
2019-11-14 15:12:56.590827-05:00
Safe
2019-11-14 15:12:56.590838-05:00
verifying: fix insert (x:tree) : nat -> tree =
  fun (n:nat) ->
    match x with
      | Leaf vs -> Node (Leaf, n, Leaf)
      | Node vs -> (match nat_lt (size (#1 vs)) (size (#3 vs)) with
                      | True c -> (match nat_lt (#2 vs) n with
                                     | True c -> Node (insert (#1 vs) (#2 vs),
                                                        n, #3 vs)
                                     | False c -> Node (insert (#1 vs) n,
                                                         #2 vs, #3 vs))
                      | False c -> (match nat_lt (#2 vs) n with
                                      | True c -> Node (#1 vs, n,
                                                         insert (#3 vs)
                                                           (#2 vs))
                                      | False c -> Node (#1 vs, #2 vs,
                                                          insert (#3 vs) n)))
2019-11-14 15:13:07.682285-05:00
Safe
2019-11-14 15:13:07.682334-05:00
verifying: fun (x:tree) ->
  match x with
    | Leaf vs -> Leaf
    | Node vs -> (fix merge (h1:tree) : tree -> tree =
                    fun (h2:tree) ->
                      match h1 with
                        | Leaf vs1 -> h2
                        | Node vs1 -> (match h2 with
                                         | Leaf vs2 -> h1
                                         | Node vs2 -> (match nat_lt (#2 vs1)
                                                                (#2 vs2) with
                                                          | True c -> 
                                                            Node (h1, 
                                                                   #2 vs2,
                                                                   merge
                                                                    (#1 vs2)
                                                                    (#3 vs2))
                                                          | False c -> 
                                                            Node (h2, 
                                                                   #2 vs1,
                                                                   merge
                                                                    (#1 vs1)
                                                                    (#3 vs1)))))
                   (#1 vs) (#3 vs)
2019-11-14 15:13:11.619930-05:00
Safe
fix f1 (t1:tree) : bool =
  match t1 with
    | Leaf N_fresh_var_0 -> True
    | Node N_fresh_var_0 -> (fun (t2:unit) ->
                               (fun (n1:unit) ->
                                  (fun (t3:unit) ->
                                     match f1 t2 with
                                       | False N_fresh_var_1 -> False
                                       | True N_fresh_var_1 -> and (f1 t3)
                                                                 (nat_eq n1
                                                                    (
                                                                    true_maximum
                                                                    t1)))
                                    (#3 N_fresh_var_0))
                                 (#2 N_fresh_var_0))
                              (#1 N_fresh_var_0)