type natoption =
  | None
  | Some of nat

struct
  type list = mu list .
    | Nil
    | Cons of (nat * list)

  type t = list

  let empty = Nil ;;

  let length =
    fix (length : t -> nat) =
      fun (l : t) ->
        match l binding lp with
        | Nil -> O
        | Cons ->
          (match lp.1 binding lp with
           | Nil -> O
           | Cons -> S (length lp.1))
  ;;

  let lookup =
    fix (lookup : t -> nat -> bool) =
      fun (l : t) -> fun (x : nat) ->
        match l binding l with
        | Nil -> False
        | Cons ->
          (match cmp_nat l.0 x binding c with
           | EQ -> True
           | LT -> lookup l.1 x
           | GT -> lookup l.1 x)
  ;;

  let insert =
    fun (l : t) ->
      fun (x : nat) ->
        Cons(x, Cons(x, l))
  ;;

  let delete =
    fix (delete : t -> nat -> t) =
      fun (l : t) -> fun (x : nat) ->
          match l binding lp with
          | Nil -> Nil
          | Cons ->
            (match lp.1 binding lp with
             | Nil -> Nil
             | Cons ->
               (match cmp_nat lp.0 x binding c with
                | LT -> Cons(lp.0, Cons(lp.0, delete lp.1 x))
                | EQ -> delete lp.1 x
                | GT -> Cons(lp.0, Cons(lp.0, delete lp.1 x))))
  ;;

  (*let union =
    fix (union : t -> t -> t) =
      fun (la : t) ->
        fun (lb : t) ->
          match la binding la with
          | Nil -> lb
          | Cons -> (union la.1 (insert lb la.0))
  ;;

  let inter =
    fix (inter : t -> t -> t) =
      fun (la : t) ->
        fun (lb : t) ->
          match la binding la with
          | Nil -> Nil
          | Cons -> (match lookup lb la.0 binding r with
                     | True -> Cons (la.0, (inter la.1 lb))
                     | False -> inter la.1 lb)
  ;;*)
end
:
sig
  type t

  val empty : t

  val length : t -> nat
  val lookup : t -> nat -> bool

  val insert : t -> nat -> t
  val delete : t -> nat -> t

  (*val union : t -> t -> t
  val inter : t -> t -> t*)
end

maintains

forall (s : t) .
  forall (i : nat) .
    forall (j : nat) .
      (implies
        (and
          (not (is_eq (cmp_nat i j)))
          (lookup s j))
        (lookup (delete s i) j))

accumulating natoption