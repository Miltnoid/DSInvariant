type list = mu list .
  | Nil
  | Cons of (nat * list)

type nat_option =
  | None
  | Some of nat

struct
  type t = list

  let empty = Nil ;;

  let length =
    fix (length : t -> nat) =
      fun (l : t) ->
        match l binding l with
        | Nil -> O
        | Cons -> S (length l.1)
  ;;

  let top =
    fun (l : t) ->
      match l binding l with
      | Nil -> None
      | Cons -> Some (l.0)
  ;;

  let insert =
    fix (insert : t -> nat -> t) =
      fun (l : t) ->
        fun (x : nat) ->
          match l binding lp with
          | Nil -> Cons (x, Nil)
          | Cons -> (match cmp_nat x lp.0 binding c with
                     | LT -> Cons (lp.0, (insert lp.1 x))
                     | EQ -> Cons (x, l)
                     | GT -> Cons (x, l))
  ;;

  let pop =
    fun (l : t) ->
      match l binding lp with
      | Nil -> (None, l)
      | Cons -> (Some (lp.0), lp.1)
  ;;

  let max =
    fix (max : t -> nat_option) =
      fun (l : t) ->
        match l binding l with
        | Nil -> None
        | Cons -> (match l.1 binding lt with
                   | Nil -> Some (l.0)
                   | Cons -> (match cmp_nat l.0 lt.0 binding u with
                              | LT -> max l.1
                              | EQ -> max l.1
                              | GT -> max (Cons (l.0, lt.1))))
  ;;
end
:
sig
  type t

  val empty : t

  val length : t -> nat
  val top : t -> nat_option

  val insert : t -> nat -> t
  val pop : t -> nat_option * t

  (* helper function *)
  val max : t -> nat_option
end

maintains

forall (h : t) .
  forall (j : nat) .
    (implies
      (match max h binding m with
       | None -> True
       | Some -> (match cmp_nat m j binding u with
                  | LT -> True
                  | EQ -> True
                  | GT -> False))
      (match top (insert h j) binding m with
       | None -> False
       | Some -> is_eq (cmp_nat m j)))