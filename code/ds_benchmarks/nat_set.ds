(* PRELUDE *)

type bool =
  | True
  | False

let not =
  fun (v : bool) ->
    match v binding i with
    | True -> False
    | False -> True
;;

let and =
  fun (b1 : bool) ->
    fun (b2 : bool) ->
      match b1 binding b1 with
      | True -> b2
      | False -> False
;;

let or =
  fun (b1 : bool) ->
    fun (b2 : bool) ->
      match b1 binding b1 with
      | True -> True
      | False -> b2
;;

let implies =
  fun (b1 : bool) ->
    fun (b2 : bool) ->
      (or (not b1) b2)
;;

(* END_PRELUDE *)



type nat = mu nat .
  | O
  | S of nat

type cmp =
  | LT
  | EQ
  | GT

let compare =
  fix (compare : nat -> nat -> cmp) =
    fun (x1 : nat) ->
      fun (x2 : nat) ->
        match x1 binding x1 with
        | O -> (match x2 binding x2 with
                | O -> EQ
                | S -> LT)
        | S -> (match x2 binding x2 with
                | O -> GT
                | S -> (compare x1) x2);;

struct
  type list = mu list .
    | Nil
    | Cons of (nat * list)

  type t = list

  let empty = Nil ;;

  let length =
    fix (length : t -> nat) =
      fun (l : t) ->
        match l binding l with
        | Nil -> O
        | Cons -> S (length l.1)
  ;;

  let lookup =
    fix (lookup : t -> nat -> bool) =
      fun (l : t) ->
        fun (x : nat) ->
          match l binding l with
          | Nil -> False
          | Cons -> match compare l.0 x binding c with
                    | EQ -> True
                    | LT -> lookup l.1 x
                    | GT -> False
  ;;

  let insert =
    fix (insert : t -> nat -> t) =
      fun (l : t) ->
        fun (x : nat) ->
          match l binding lp with
          | Nil -> Cons (x, Nil)
          | Cons -> (match compare x lp.0 binding c with
                     | LT -> Cons (x, l)
                     | EQ -> l
                     | GT -> Cons (lp.0, (insert lp.1 x)))
  ;;

  let delete =
    fix (delete : t -> nat -> t) =
      fun (l : t) ->
        fun (x : nat) ->
          match l binding lp with
          | Nil -> Nil
          | Cons -> (match compare x lp.0 binding c with
                     | LT -> l
                     | EQ -> lp.1
                     | GT -> Cons (lp.0, (delete lp.1 x)))
  ;;

  let union =
    fix (union : t -> t -> t) =
      fun (la : t) ->
        fun (lb : t) ->
          match la binding la with
          | Nil -> lb
          | Cons -> (union la.1 (insert lb la.0))
  ;;

  let inter =
    fix (inter : t -> t -> t) =
      fun (la : t) ->
        fun (lb : t) ->
          match la binding la with
          | Nil -> Nil
          | Cons -> (match lookup lb la.0 binding r with
                     | True -> Cons (la.0, (inter la.1 lb))
                     | False -> inter la.1 lb)
  ;;
end
:
sig
  type t

  val empty : t

  val length : t -> nat
  val lookup : t -> nat -> bool

  val insert : t -> nat -> t
  val delete : t -> nat -> t

  val union : t -> t -> t
  val inter : t -> t -> t
end

maintains

forall (s : t) .
  forall (i : nat) .
    forall (j : nat) .
      (and
        (not (lookup (delete s j) j))
        (implies (lookup (delete s i) j)
                 (lookup s j)))